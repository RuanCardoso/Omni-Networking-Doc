{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#overview","title":"Overview","text":"<p>Omni Networking is a comprehensive networking solution that offers features for high-performance multiplayer game development in Unity. Omni provides functionalities for <code>Database Management, RouteX, RPC, gRPC, Port Forwarding, Network Variables, Binary and JSON serialization</code>, among others.</p> <p>Omni supports only versions <code>2021.3 and above</code>, as it utilizes the latest APIs available in .NET Standard 2.1 and beyond to achieve the highest possible performance.</p> <p>Compatibility Table:</p> Unity Version Compatibilidade Unity 2021.3 (LTS) \u2705 Unity 2022.3 (LTS) \u2705 Unity 6 (LTS) \u2705 <p>Warning</p> <p>Versions not listed in the compatibility table may not be fully supported and could exhibit unexpected behavior. For the most reliable experience, please refer to the Releases page to verify compatibility with the latest available versions.</p>"},{"location":"#installation","title":"Installation","text":"<p>Warning</p> <p>Before getting started, it's important to be aware that Omni includes some dependencies by default:</p> <ul> <li>Newtonsoft Json</li> <li>Memory Pack</li> <li>UniTask</li> <li>DOTween</li> <li>Database modules, among others.</li> </ul> <p>Make sure to remove these dependencies from your project if they already exist. For this reason, I recommend always starting with a new project to avoid any conflicts.</p> <ol> <li>Download the latest Omni package from the Releases.</li> <li>Import the package into your project.</li> </ol>"},{"location":"#setup","title":"Setup","text":"<p>Note</p> <p>After importing the package and waiting for the recompilation, some macros are automatically defined:</p> <ul> <li><code>OMNI_RELEASE</code></li> <li><code>OMNI_DEBUG</code></li> <li><code>OMNI_SERVER</code> &lt;- is defined when the target platform is set to <code>DEDICATED SERVER</code> in the <code>Build Settings</code>.</li> </ul> <p>You can use these macros to switch between release and debug builds, by default the <code>OMNI_DEBUG</code> macro is defined.</p> <pre><code>#if OMNI_RELEASE\nprint(\"You're in release mode\");\n#endif\n\n#if OMNI_DEBUG\nprint(\"You're in debug mode\");\n#endif\n\n#if OMNI_SERVER\nprint(\"You're in server mode\");\n#endif\n</code></pre> <p>You can use these macros to strip the code from the build process for security reasons.</p> <pre><code>#if OMNI_SERVER\n// sensitive server code\n#else\n// Client code\n#endif\n</code></pre> <ol> <li>Go to the Unity Navigation Bar and select <code>Omni Networking</code>.</li> <li>Click the <code>Setup</code> menu item.</li> </ol> <p>A GameObject named <code>Network Manager</code> will be created in the scene. This object is responsible for the connection and contains all the network settings.</p> <p>Warning</p> <p>The <code>Network Manager</code> object must be in the scene for Omni to function properly and not should be destroyed or renamed.</p> <p>Note</p> <p>The <code>Network Manager</code> object has two child objects that can optionally host client and server scripts. It\u2019s optional to place scripts on these objects. When scripts are assigned to these child objects, Unity automatically separates them during the build process. In <code>release</code> mode, server scripts won\u2019t run in the client build, and vice versa.</p> <p>Note: This approach doesn\u2019t strip the code; it merely prevents execution by removing the objects from the scene at build time. To strip the code, consider using the <code>OMNI_RELEASE</code>, <code>OMNI_DEBUG</code>, and <code>OMNI_SERVER</code> macros.</p> <ol> <li>Select the <code>Network Manager</code> object in the scene to view the network settings.</li> </ol> Option Description <code>Public IPv4</code> The public IPv4 address of the client <code>Public IPv6</code> The public IPv6 address of the client"},{"location":"#modules","title":"Modules","text":"Modules Description <code>Console Module</code> Allows sending and receiving commands in the console when the build is for a server. <code>Match Module</code> Allows matchmaking, creating, joining, and deleting groups, among other features. <code>Tick Module</code> Allows the use of a tick-based system for sending messages and other tick-based operations. <code>Sntp Module</code> Provides a high-precision synchronized clock between all clients and the server."},{"location":"#connection-settings","title":"Connection Settings","text":"Option Description <code>Server Port</code> The port number on which the server listens for incoming connections. <code>Client Port</code> The port number on which the client listens for incoming connections. Option Description <code>Host Address</code> The IP address or hostname of the server to which the client will connect. <code>Port</code> The port number on which the server is listening and which will be used for the connection."},{"location":"#miscellaneous","title":"Miscellaneous","text":"Option Description <code>Tick Rate</code> The rate at which the game loop processes updates, measured in ticks per second. <code>Pool Capacity</code> Represents, in bytes, the size of the buffer <code>(byte[])</code> internally allocated for each <code>DataBuffer</code>. <code>Pool Size</code> Specifies the number of <code>DataBuffer</code> instances pre-allocated in the pool, ready for use. <code>Max Fps On Client</code> The maximum frame rate that the client will attempt to render, measured in frames per second. <code>Auto Start Server</code> Whether the server should automatically start when the application launches. <code>Auto Start Client</code> Whether the client should automatically start when the application launches. <code>Use UTF-8 Encoding</code> Whether to use UTF-8 encoding for text data in the application. <code>Use Binary Serialization</code> Coming soon..... DON'T USE IT YET! Experimental feature. <code>Use Unaligned Memory</code> Whether to allow unaligned memory access, which may affect performance and compatibility. <code>Run In Background</code> Whether the application should continue running while in the background, even when not in focus."},{"location":"#permissions","title":"Permissions","text":"Option Description <code>Allow NetVar's From Client</code> Determines whether client-side changes to network variables are permitted, allowing clients to modify networked variables directly. <code>Allow Across Group Message</code> Allows messages to be sent across different network groups, enabling communication between distinct groups in the network."},{"location":"#registered-prefabs","title":"Registered Prefabs","text":"<p>This list is used to automatically instantiate network objects. When a network object is instantiated by name or indexer, the object will be looked up in this list and instantiated automatically. Remember, manual instantiation is also available, and using this list is not required.</p>"},{"location":"#transporter-settings","title":"Transporter Settings","text":"<p>The Transporter Settings section allows you to configure various network transport parameters, including disconnection timeout, network event processing per frame, lag simulation, channel setup, IPv6 support, max connections, ping intervals, and more. Available options may vary based on the selected transporter.</p> <p>Currently, two transporters are supported: Lite Transporter and KCP Transporter, with additional options planned for future releases.</p> Transporter ReliableOrdered Unreliable ReliableUnordered Sequenced ReliableSequenced Browser Compatibility Lite Transporter \u2705 \u2705 \u2705 \u2705 \u2705 \u274c Kcp Transporter \u2705 \u2705 \u274c \u274c \u274c \u274c Web Socket Transporter \u2705 \u274c \u274c \u274c \u274c \u23f3 Available Soon <p>Warning</p> <p>The KCP Transporter is currently experimental and may contain unresolved issues. Use it with caution and consider thoroughly testing for stability in your specific use case.</p> <p>Note</p> <p>By default, Omni utilizes the Lite Transporter for network operations. To switch to a different transporter, follow these steps:</p> <ol> <li>Remove the Lite Transporter: In your scene, locate the <code>Network Manager</code> object. Select it, and remove the <code>Lite Transporter</code> component from this object.</li> <li>Add the Desired Transporter: Once the Lite Transporter is removed, add the component of your preferred transporter to the <code>Network Manager</code> object.</li> </ol> <p>This configuration enables you to tailor network transport settings to suit the specific requirements of your project, ensuring optimal compatibility and performance.</p> <p>Warning</p> <p>Some properties or functions may be unavailable for certain transporters. If an incompatible option is used, an error message will appear to inform you of the mismatch.</p> <p>For detailed information on each transporter and their specific features, consult the respective documentation:</p> <ul> <li>LiteNetLib Documentation</li> <li>KCP Transporter (kcp2k) Documentation</li> </ul>"},{"location":"#known-issues","title":"Known Issues","text":"<p>Warning</p> <p>Public IP Configuration Required: Omni relies on the correct IP configuration in the <code>Public IP</code> field of the <code>Network Manager</code>. When sharing your project, this field may display an incorrect IP address from another user. To update it, open the context menu of the <code>Network Manager</code> script, press Get External IP, and Omni will automatically update the field to reflect your current IP address.</p> <p>Warning</p> <p>Omni Package Installation Issues: If you experience problems during the Omni package installation, such as Unity freezing or crashing, and the necessary macros are not defined, you may need to manually reset the macros. To do this, go to the root folder of the Omni package and delete the hidden file that begins with <code>omni_macros</code>. Ensure hidden files are visible in your file explorer to locate this file.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#network-manager","title":"Network Manager","text":"<p>The <code>NetworkManager</code> class is the core component of the Omni Networking library for Unity. It provides a framework for managing network operations, including client-server communication, synchronization, and data transmission.</p> <p>The <code>NetworkManager</code> class is responsible for handling the initialization, configuration, and management of the network environment. It acts as a central hub for network-related operations, such as connecting to a server, handling client-server communication, and managing network events.</p>"},{"location":"api_reference/#methods","title":"Methods","text":""},{"location":"api_reference/#addprefab","title":"AddPrefab","text":"<p>Adds a prefab to the NetworkManager's registration list if it hasn\u2019t been registered already.</p> <ul> <li>Signature: <code>public static void AddPrefab(NetworkIdentity prefab)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to add to the registration list. <p>Description</p> <p>Registers a <code>NetworkIdentity</code> prefab for network spawning. This method checks if a prefab with the same name already exists in the list, and if so, it will not add it again. This ensures that each prefab is unique in the registration list.</p> <p>Example</p> <pre><code>   // Example of adding a prefab to the registration list\n   NetworkManager.AddPrefab(myPrefabIdentity);\n</code></pre>"},{"location":"api_reference/#getprefab","title":"GetPrefab","text":"<p>Retrieves a prefab from the NetworkManager's registered list by either its name or index.</p> <ul> <li>Signature: </li> <li><code>public static NetworkIdentity GetPrefab(string prefabName)</code></li> <li><code>public static NetworkIdentity GetPrefab(int index)</code></li> </ul> GetPrefab (string prefabName)GetPrefab (int index) <p>Retrieves a prefab by its name.</p> Parameter Type Description <code>prefabName</code> <code>string</code> The name of the prefab to retrieve. <ul> <li>Returns: <code>NetworkIdentity</code> \u2014 The prefab with the specified name.</li> <li>Exceptions: Throws an <code>Exception</code> if the prefab with the specified name is not found.</li> </ul> Example <pre><code>   // Example of retrieving a prefab by name\n   try\n   {\n       NetworkIdentity playerPrefab = NetworkManager.GetPrefab(\"Player\");\n       Debug.Log(\"Prefab retrieved successfully by name.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre> <p>Retrieves a prefab by its index in the registered list.</p> Parameter Type Description <code>index</code> <code>int</code> The index of the prefab to retrieve in the list. <ul> <li>Returns: <code>NetworkIdentity</code> \u2014 The prefab at the specified index.</li> <li>Exceptions: Throws an <code>IndexOutOfRangeException</code> if the index is out of bounds.</li> </ul> Example <pre><code>   // Example of retrieving a prefab by index\n   try\n   {\n       NetworkIdentity enemyPrefab = NetworkManager.GetPrefab(0);\n       Debug.Log(\"Prefab retrieved successfully by index.\");\n   }\n   catch (IndexOutOfRangeException ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre> <p>Description</p> <p>This method provides two overloads for retrieving a <code>NetworkIdentity</code> prefab from the NetworkManager\u2019s registration list. You can either search by the name of the prefab or by its index within the list. If a matching prefab is found, it is returned; otherwise, an appropriate exception is thrown, ensuring that only registered prefabs are used for network spawning.</p> <p>Remarks</p> <ul> <li>By Name: Throws an <code>Exception</code> if the prefab with the specified name is not found in the registration list.</li> <li>By Index: Throws an <code>IndexOutOfRangeException</code> if the index is out of bounds.</li> <li>Useful for scenarios where dynamic instantiation of networked objects is required, either by specific name or by predefined order in the list.</li> </ul>"},{"location":"api_reference/#connect","title":"Connect","text":"<p>Establishes a connection to a specified server address and port. There are two overloads for this method, allowing you to specify a client listening port if needed.</p> <ul> <li>Signature:</li> <li><code>public static void Connect(string address, int port)</code></li> <li><code>public static void Connect(string address, int port, int listenPort)</code></li> </ul> Connect (string address, int port)Connect (string address, int port, int listenPort) <p>Connects to the server using the specified <code>address</code> and <code>port</code>. The client will use the default listening port defined in <code>Manager.m_ClientListenPort</code>.</p> Parameter Type Description <code>address</code> <code>string</code> The IP address of the server. <code>port</code> <code>int</code> The port number on the server. <ul> <li>Exceptions: Throws an <code>Exception</code> if the client is already active, instructing to stop the client before reconnecting.</li> </ul> Example <pre><code>// Connect to a server with default client listening port\nNetworkManager.Connect(\"192.168.1.1\", 7777);\n</code></pre> <p>Connects to the server using the specified <code>address</code> and <code>port</code>, with the client listening on the specified <code>listenPort</code>.</p> Parameter Type Description <code>address</code> <code>string</code> The IP address of the server. <code>port</code> <code>int</code> The port number on the server. <code>listenPort</code> <code>int</code> The port number on which the client listens. <ul> <li>Exceptions: Throws an <code>Exception</code> if the client is already active, instructing to stop the client before reconnecting.</li> </ul> Example <pre><code>// Connect to a server with a custom client listening port\nNetworkManager.Connect(\"192.168.1.1\", 7777, 8888);\n</code></pre> <p>Description</p> <p>The <code>Connect</code> method initiates a connection to the server at a given IP address and port. If the client is already active, an exception is thrown to prevent multiple connections. In the server build configuration (<code>UNITY_SERVER</code>), client connections are disabled.</p> <p>Remarks</p> <ul> <li>Server Build: In a server build (<code>UNITY_SERVER</code>), client connections are not permitted and will log a message instead.</li> <li>Exception Handling: Ensure to call <code>StopClient()</code> before reconnecting if the client is already active to avoid exceptions.</li> <li>Listening Port: Use the overload with <code>listenPort</code> if a custom listening port is required for the client.</li> </ul>"},{"location":"api_reference/#disconnectpeer","title":"DisconnectPeer","text":"<p>Disconnects a specified peer from the server.</p> <ul> <li>Signature: <code>public static void DisconnectPeer(NetworkPeer peer)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>peer</code> <code>NetworkPeer</code> The network peer to disconnect. <p>Description</p> <p>The <code>DisconnectPeer</code> method removes the specified <code>NetworkPeer</code> from the server if the server is currently active. If the server has not been initialized, an exception is thrown to prompt server startup before disconnection.</p> <p>Example</p> <pre><code>   // Example of disconnecting a peer\n   try\n   {\n       NetworkPeer somePeer = GetPeer(); // Assume this retrieves a valid NetworkPeer\n       NetworkManager.DisconnectPeer(somePeer);\n       Debug.Log(\"Peer disconnected successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#disconnect","title":"Disconnect","text":"<p>Disconnects the local client from the server.</p> <ul> <li>Signature: <code>public static void Disconnect()</code></li> </ul> <p>Description</p> <p>The <code>Disconnect</code> method terminates the connection between the local client and the server, if the client is currently active. If the client has not been initialized, an exception is thrown to prompt a connection attempt before disconnection.</p> <p>Example</p> <pre><code>   // Example of disconnecting the client from the server\n   try\n   {\n       NetworkManager.Disconnect();\n       Debug.Log(\"Client disconnected successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#stopclient","title":"StopClient","text":"<p>Stops the local client and ends its connection to the server.</p> <ul> <li>Signature: <code>public static void StopClient()</code></li> </ul> <p>Description</p> <p>The <code>StopClient</code> method halts the local client\u2019s network operations, fully disconnecting it from the server if it is currently active. If the client has not been initialized, an exception is thrown to prompt a connection attempt before stopping.</p> <p>Example</p> <pre><code>   // Example of stopping the client\n   try\n   {\n       NetworkManager.StopClient();\n       Debug.Log(\"Client stopped successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#fastwrite","title":"FastWrite","text":"<p>Writes one or more primitive values to a <code>DataBuffer</code>, utilizing <code>stackalloc</code> to avoid allocations and ensure high performance. This method is available in multiple overloads, allowing for writing up to six primitive values in a single call.</p> <ul> <li>Signature:</li> <li><code>public static DataBuffer FastWrite&lt;T1&gt;(T1 t1) where T1 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2&gt;(T1 t1, T2 t2) where T1 : unmanaged where T2 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3&gt;(T1 t1, T2 t2, T3 t3) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4&gt;(T1 t1, T2 t2, T3 t3, T4 t4) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4, T5&gt;(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4, T5, T6&gt;(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged where T6 : unmanaged</code></li> </ul> <p>Description</p> <p>Each overload of <code>FastWrite</code> allows for writing up to six unmanaged primitive values to a <code>DataBuffer</code>. By using <code>stackalloc</code>, these methods avoid memory allocations, making them highly efficient for network messaging. The returned <code>DataBuffer</code> must be disposed or used within a <code>using</code> statement to ensure proper memory management.</p> <p>Returns</p> <ul> <li><code>DataBuffer</code>: The network message buffer containing the written values.</li> </ul> FastWrite (T1 t1)FastWrite (T1 t1, T2 t2)FastWrite (T1 t1, T2 t2, T3 t3)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4, T5 t5)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) <p>Writes a single unmanaged value to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes two unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes three unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A'))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes four unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes five unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. <code>t5</code> <code>T5</code> The fifth value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true, 99))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes six unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. <code>t5</code> <code>T5</code> The fifth value to write to the buffer. <code>t6</code> <code>T6</code> The sixth value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true, 99, 2.718))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Remarks</p> <ul> <li>Disposal: The caller must ensure that the returned <code>DataBuffer</code> is disposed or used within a <code>using</code> statement to prevent memory leaks.</li> <li>Performance: By using <code>stackalloc</code>, this method avoids heap allocations, offering high performance for network messaging.</li> <li>Generic Constraints: Only unmanaged types are allowed, ensuring compatibility with <code>DataBuffer</code> for efficient serialization.</li> </ul>"},{"location":"api_reference/#frombinary","title":"FromBinary","text":"<p>Deserializes an object from binary format using <code>MemoryPackSerializer</code>.</p> <ul> <li>Signature: <code>public static T FromBinary&lt;T&gt;(byte[] data, MemoryPackSerializerOptions settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to deserialize. <p>Parameters</p> Parameter Type Description <code>data</code> <code>byte[]</code> The byte array containing the binary data to deserialize. <code>settings</code> <code>MemoryPackSerializerOptions</code> Optional settings for deserialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>FromBinary</code> method deserializes an object of type <code>T</code> from a binary byte array using the <code>MemoryPackSerializer</code>. It allows specifying optional deserialization settings through <code>MemoryPackSerializerOptions</code>. If no settings are provided, the method uses the default settings defined in <code>BufferWriterExtensions.DefaultMemoryPackSettings</code>.</p> <p>Returns</p> <ul> <li><code>T</code>: The deserialized object of type <code>T</code>.</li> </ul> <p>Example</p> <pre><code>// Example of deserializing an object from binary data\nbyte[] binaryData = GetBinaryData(); // Assume this retrieves a valid byte array\nMyObject deserializedObject = NetworkManager.FromBinary&lt;MyObject&gt;(binaryData);\n</code></pre>"},{"location":"api_reference/#tobinary","title":"ToBinary","text":"<p>Converts an object to binary format using <code>MemoryPackSerializer</code>.</p> <ul> <li>Signature: <code>public static byte[] ToBinary&lt;T&gt;(T obj, MemoryPackSerializerOptions settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to serialize. <p>Parameters</p> Parameter Type Description <code>obj</code> <code>T</code> The object to be converted to binary format. <code>settings</code> <code>MemoryPackSerializerOptions</code> Optional settings for serialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>ToBinary</code> method serializes an object of type <code>T</code> into a binary byte array using <code>MemoryPackSerializer</code>. It allows specifying optional serialization settings via <code>MemoryPackSerializerOptions</code>. If no settings are provided, the method uses the default settings from <code>BufferWriterExtensions.DefaultMemoryPackSettings</code>.</p> <p>Returns</p> <ul> <li><code>byte[]</code>: A byte array representing the binary serialization of the object.</li> </ul> <p>Example</p> <pre><code>// Example of serializing an object to binary data\nMyObject obj = new MyObject();\nbyte[] binaryData = NetworkManager.ToBinary(obj);\n\n// Example with custom settings\nMemoryPackSerializerOptions customSettings = new MemoryPackSerializerOptions\n{\n    // Custom settings configuration\n};\nbyte[] binaryData = NetworkManager.ToBinary(obj, customSettings);\n</code></pre>"},{"location":"api_reference/#fromjson","title":"FromJson","text":"<p>Deserializes an object from JSON format.</p> <ul> <li>Signature: <code>public static T FromJson&lt;T&gt;(string json, JsonSerializerSettings settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to deserialize. <p>Parameters</p> Parameter Type Description <code>json</code> <code>string</code> The JSON string to deserialize. <code>settings</code> <code>JsonSerializerSettings</code> Optional settings for JSON deserialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>FromJson</code> method deserializes an object of type <code>T</code> from a JSON string. This method allows specifying optional deserialization settings via <code>JsonSerializerSettings</code>. If no settings are provided, the default settings from <code>BufferWriterExtensions.DefaultJsonSettings</code> are used.</p> <p>Returns</p> <ul> <li><code>T</code>: The deserialized object of type <code>T</code>.</li> </ul> <p>Example</p> <pre><code>// Example of deserializing an object from a JSON string\nstring jsonString = \"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":30}\";\nPerson person = NetworkManager.FromJson&lt;Person&gt;(jsonString);\n\n// Example with custom settings\nJsonSerializerSettings customSettings = new JsonSerializerSettings\n{\n    Formatting = Formatting.Indented\n};\nPerson person = NetworkManager.FromJson&lt;Person&gt;(jsonString, customSettings);\n</code></pre>"},{"location":"api_reference/#tojson","title":"ToJson","text":"<p>Converts an object to JSON format.</p> <ul> <li>Signature: <code>public static string ToJson&lt;T&gt;(T obj, JsonSerializerSettings settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to serialize. <p>Parameters</p> Parameter Type Description <code>obj</code> <code>T</code> The object to be converted to JSON format. <code>settings</code> <code>JsonSerializerSettings</code> Optional settings for JSON serialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>ToJson</code> method serializes an object of type <code>T</code> into a JSON string using <code>JsonConvert</code>. This method allows for optional JSON serialization settings via <code>JsonSerializerSettings</code>. If no settings are specified, it uses the default settings defined in <code>BufferWriterExtensions.DefaultJsonSettings</code>.</p> <p>Returns</p> <ul> <li><code>string</code>: A JSON string representation of the serialized object.</li> </ul> <p>Example</p> <pre><code>// Example of serializing an object to JSON format\nPerson person = new Person { Name = \"John\", Age = 30 };\nstring jsonString = NetworkManager.ToJson(person);\n\n// Example with custom settings\nJsonSerializerSettings customSettings = new JsonSerializerSettings\n{\n    Formatting = Formatting.Indented\n};\nstring jsonString = NetworkManager.ToJson(person, customSettings);\n</code></pre>"},{"location":"api_reference/#initializemodule","title":"InitializeModule","text":"<p>Initializes a specified network module based on the provided <code>Module</code> type.</p> <ul> <li>Signature: <code>public static void InitializeModule(Module module)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>module</code> <code>Module</code> The type of module to initialize. <p>Description</p> <p>The <code>InitializeModule</code> method initializes a network module based on the specified <code>Module</code> type. This includes setting up components for ticking, network time, console, connections, and matchmaking as required. The method ensures that the initialization occurs on the main thread and applies appropriate configurations based on each module\u2019s unique requirements.</p> <p>Module Types</p> <ul> <li><code>TickSystem</code>: Initializes a network tick system if one doesn\u2019t already exist. Sets up the tick rate using <code>Manager.m_TickRate</code>.</li> <li><code>NtpClock</code>: Initializes an SNTP clock based on <code>NetworkClock</code> settings, configuring interval and tick timing.</li> <li><code>Console</code>: Initializes a <code>NetworkConsole</code> instance.</li> <li><code>Connection</code>: Sets up the client and server transporters, checks for a transporter component, and configures network connection. Includes logic for auto-starting the server and client based on specific address conditions and the current build configuration.</li> <li><code>Matchmaking</code>: Initializes the network matchmaking module.</li> </ul> <p>Example</p> <pre><code>// Example of initializing the TickSystem module\nNetworkManager.InitializeModule(Module.TickSystem);\n\n// Example of initializing the Connection module\ntry\n{\n    NetworkManager.InitializeModule(Module.Connection);\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre> <p>Remarks</p> <ul> <li>Thread Safety: The method enforces that initialization occurs on the main thread to prevent multithreading issues.</li> <li>Connection Transporter: Throws an Exception if no transporter is found on NetworkManager when initializing the Connection module.</li> <li>Auto-Start Logic: In the Connection module, auto-start behavior is configured based on the client\u2019s address. The server will only auto-start if the address is recognized as localhost or a public IP address.</li> <li>Build Configuration: Auto-starting behavior may vary based on build configuration. For instance, in OMNI_RELEASE builds, both server and client auto-start are enabled by default.</li> </ul>"},{"location":"api_reference/#loadscene-loadsceneasync","title":"LoadScene / LoadSceneAsync","text":"<p>Loads a scene by name or index, with options for synchronous or asynchronous loading. These methods also provide optional parameters to destroy the current scene before loading a new one.</p> <ul> <li>Signature:</li> <li><code>public static void LoadScene(string sceneName, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static AsyncOperation LoadSceneAsync(string sceneName, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static void LoadScene(int index, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static AsyncOperation LoadSceneAsync(int index, LoadSceneMode mode = LoadSceneMode.Single)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Specifies whether to load the scene in <code>Single</code> or <code>Additive</code> mode (default is <code>Single</code>). <p>Description</p> <p>Each overload of <code>LoadScene</code> and <code>LoadSceneAsync</code> allows loading scenes either by name or by build index, with the option to specify loading in single or additive mode. The methods also include a call to <code>DestroyScene</code> to clear the current scene before loading the new one, supporting smooth transitions and memory management.</p> <p>Overloads</p> LoadScene (string sceneName, LoadSceneMode mode = LoadSceneMode.Single)LoadSceneAsync (string sceneName, LoadSceneMode mode = LoadSceneMode.Single)LoadScene (int index, LoadSceneMode mode = LoadSceneMode.Single)LoadSceneAsync (int index, LoadSceneMode mode = LoadSceneMode.Single) <p>Loads a scene by its name in synchronous mode.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example <pre><code>// Load a scene by name\nNetworkManager.LoadScene(\"MainScene\");\n</code></pre> <p>Loads a scene by its name in asynchronous mode, returning an <code>AsyncOperation</code>.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example <pre><code>// Load a scene asynchronously by name\nAsyncOperation loadOperation = NetworkManager.LoadSceneAsync(\"MainScene\");\n</code></pre> <p>Loads a scene by its build index in synchronous mode.</p> Parameter Type Description <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example <pre><code>// Load a scene by build index\nNetworkManager.LoadScene(1);\n</code></pre> <p>Loads a scene by its build index in asynchronous mode, returning an <code>AsyncOperation</code>.</p> Parameter Type Description <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example <pre><code>// Load a scene asynchronously by build index\nAsyncOperation loadOperation = NetworkManager.LoadSceneAsync(1);\n</code></pre> <p>Remarks</p> <ul> <li>DestroyScene: Each method calls <code>DestroyScene</code> before loading to remove the current scene and free resources.</li> <li>LoadSceneMode: Allows loading in <code>Single</code> mode, which replaces the current scene, or <code>Additive</code> mode, which loads the new scene on top of the existing one.</li> <li>AsyncOperation: In asynchronous methods, an <code>AsyncOperation</code> is returned, which can be used to track the progress of scene loading.</li> <li>Error Handling: Ensure the specified scene name or index is valid to avoid loading errors.</li> </ul>"},{"location":"api_reference/#unloadsceneasync","title":"UnloadSceneAsync","text":"<p>Asynchronously unloads a scene by its name or index with options for unloading behavior.</p> <ul> <li>Signature:</li> <li><code>public static AsyncOperation UnloadSceneAsync(string sceneName, UnloadSceneOptions options = UnloadSceneOptions.None)</code></li> <li><code>public static AsyncOperation UnloadSceneAsync(int index, bool useBuildIndex = false, UnloadSceneOptions options = UnloadSceneOptions.None)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to unload. <code>index</code> <code>int</code> The index of the scene to unload, which can refer to the build index or scene load order. <code>useBuildIndex</code> <code>bool</code> Indicates if the <code>index</code> parameter should be interpreted as the build index (default is <code>false</code>). <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). <p>Description</p> <p>The <code>UnloadSceneAsync</code> method provides asynchronous scene unloading capabilities. You can specify the scene to unload either by its name or index, with the option to interpret the index as the build index. Each method first calls <code>DestroyScene</code> to handle any necessary scene cleanup before initiating the asynchronous unloading operation using <code>SceneManager.UnloadSceneAsync</code>.</p> <p>Overloads</p> UnloadSceneAsync (string sceneName, UnloadSceneOptions options = UnloadSceneOptions.None)UnloadSceneAsync (int index, bool useBuildIndex = false, UnloadSceneOptions options = UnloadSceneOptions.None) <p>Unloads a scene asynchronously by its name.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to unload. <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). Example <pre><code>// Unload a scene asynchronously by name\nAsyncOperation unloadOperation = NetworkManager.UnloadSceneAsync(\"MainScene\");\n</code></pre> <p>Unloads a scene asynchronously by its index, with the option to interpret the index as the build index.</p> Parameter Type Description <code>index</code> <code>int</code> The index of the scene to unload. <code>useBuildIndex</code> <code>bool</code> Whether the index refers to the build index (default is <code>false</code>). <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). Example <pre><code>// Unload a scene asynchronously by build index\nAsyncOperation unloadOperation = NetworkManager.UnloadSceneAsync(1, useBuildIndex: true);\n</code></pre> <p>Remarks</p> <ul> <li>DestroyScene: Each method calls <code>DestroyScene</code> before unloading to handle any necessary cleanup operations and prevent memory leaks.</li> <li>UnloadSceneOptions: Options can be provided for customizing the unloading process, such as removing dependencies.</li> <li>AsyncOperation: Returns an <code>AsyncOperation</code> that can be used to track the progress of the unloading process.</li> <li>Usage: Ideal for offloading scenes when they are no longer needed, helping to manage memory and resources efficiently.</li> </ul>"},{"location":"api_reference/#spawnonclient","title":"SpawnOnClient","text":"<p>Instantiates a network identity on the client.</p> <ul> <li>Signature: <code>public static NetworkIdentity SpawnOnClient(NetworkIdentity prefab, int peerId, int identityId)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peerId</code> <code>int</code> The ID of the peer who owns the instantiated object. <code>identityId</code> <code>int</code> The ID of the instantiated object. <p>Description</p> <p>The <code>SpawnOnClient</code> method instantiates a <code>NetworkIdentity</code> object on the client. It checks if the instantiated object is owned by the local player and updates the <code>LocalPlayer</code> reference if appropriate. After instantiation, it notifies the server that this identity has been spawned on the client side.</p> <p>Returns</p> <ul> <li><code>NetworkIdentity</code>: The instantiated network identity object.</li> </ul> <p>Example</p> <pre><code>// Example of spawning a network identity on the client\nNetworkIdentity playerPrefab = GetPlayerPrefab(); // Assume this retrieves a valid NetworkIdentity prefab\nNetworkIdentity newPlayer = NetworkManager.SpawnOnClient(playerPrefab, peerId: 1, identityId: 1001);\nDebug.Log(\"Player instantiated on client: \" + newPlayer.name);\n</code></pre>"},{"location":"api_reference/#spawnonserver","title":"SpawnOnServer","text":"<p>Instantiates a network identity on the server for a specific peer or with a specified ID.</p> <ul> <li>Signature:</li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, NetworkPeer peer)</code></li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, NetworkPeer peer, int identityId)</code></li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, int peerId, int identityId = 0)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the instantiated object. <code>peerId</code> <code>int</code> The ID of the peer who will receive the instantiated object (for overloads without <code>peer</code>). <code>identityId</code> <code>int</code> The ID of the instantiated object. If not provided, a unique ID will be dynamically generated. <p>Description</p> <p>The <code>SpawnOnServer</code> method provides multiple overloads to instantiate a <code>NetworkIdentity</code> object on the server. The instantiation can be performed for a specific peer, identified either by a <code>NetworkPeer</code> object or a <code>peerId</code>. If an <code>identityId</code> is not provided, a unique ID is generated dynamically.</p> <p>Overloads</p> SpawnOnServer (NetworkIdentity prefab, NetworkPeer peer)SpawnOnServer (NetworkIdentity prefab, NetworkPeer peer, int identityId)SpawnOnServer (NetworkIdentity prefab, int peerId, int identityId = 0) <p>Instantiates a network identity on the server for a specific peer.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the object. Example <pre><code>// Example of spawning a network identity on the server for a specific peer\nNetworkIdentity playerPrefab = GetPlayerPrefab();\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, somePeer);\n</code></pre> <p>Instantiates a network identity on the server for a specific peer with a specified identity ID.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the object. <code>identityId</code> <code>int</code> The ID of the instantiated object. Example <pre><code>// Example of spawning a network identity with a specific ID on the server for a peer\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, somePeer, 1001);\n</code></pre> <p>Instantiates a network identity on the server using a peer ID and an optional identity ID. If <code>identityId</code> is not provided, a unique ID is generated dynamically.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peerId</code> <code>int</code> The ID of the peer who will receive the object. <code>identityId</code> <code>int</code> The ID of the instantiated object, or <code>0</code> for a unique ID. Example <pre><code>// Example of spawning a network identity on the server by peer ID, with auto-generated ID\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, peerId: 1);\n</code></pre> <p>Remarks</p> <ul> <li>Dynamic ID Generation: If <code>identityId</code> is <code>0</code>, the method generates a unique ID for the instantiated object using <code>NetworkHelper.GenerateDynamicUniqueId()</code>.</li> <li>Peer Association: The instantiated object is associated with the specified peer, allowing for ownership and network synchronization based on peer ID.</li> <li>Usage: Suitable for spawning networked objects on the server side, with flexibility for assigning specific identity IDs or generating them dynamically.</li> </ul>"},{"location":"api_reference/#properties","title":"Properties","text":""},{"location":"api_reference/#clientlistenport","title":"ClientListenPort","text":"<p>Gets the port on which the client listens for incoming connections.</p> <ul> <li>Signature: <code>public static int ClientListenPort</code></li> </ul> <p>Description</p> <p>The <code>ClientListenPort</code> property provides access to the client\u2019s listening port, as configured in <code>Manager.m_ClientListenPort</code>. This port is used for network communications on the client side, enabling it to receive messages from the server.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number on which the client listens.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the client's listening port\nint clientPort = NetworkManager.ClientListenPort;\nDebug.Log(\"Client listening on port: \" + clientPort);\n</code></pre>"},{"location":"api_reference/#serverlistenport","title":"ServerListenPort","text":"<p>Gets the port on which the server listens for incoming connections.</p> <ul> <li>Signature: <code>public static int ServerListenPort</code></li> </ul> <p>Description</p> <p>The <code>ServerListenPort</code> property provides access to the server\u2019s listening port, as configured in <code>Manager.m_ServerListenPort</code>. This port is used for network communications on the server side, enabling it to accept incoming connections from clients.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number on which the server listens.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the server's listening port\nint serverPort = NetworkManager.ServerListenPort;\nDebug.Log(\"Server listening on port: \" + serverPort);\n</code></pre>"},{"location":"api_reference/#connectport","title":"ConnectPort","text":"<p>Gets the port on which the client connects to the server.</p> <ul> <li>Signature: <code>public static int ConnectPort</code></li> </ul> <p>Description</p> <p>The <code>ConnectPort</code> property provides access to the port number that the client uses to connect to the server, as configured in <code>Manager.m_ConnectPort</code>. This port is the endpoint on the server to which the client establishes a connection.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number that the client uses to connect to the server.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the server's connection port\nint serverConnectionPort = NetworkManager.ConnectPort;\nDebug.Log(\"Client will connect to server on port: \" + serverConnectionPort);\n</code></pre>"},{"location":"api_reference/#connectaddress","title":"ConnectAddress","text":"<p>Gets the IP address or hostname that the client uses to connect to the server.</p> <ul> <li>Signature: <code>public static string ConnectAddress</code></li> </ul> <p>Description</p> <p>The <code>ConnectAddress</code> property provides access to the IP address or hostname of the server that the client connects to, as configured in <code>Manager.m_ConnectAddress</code>. This address is used as the endpoint for the client\u2019s connection to the server.</p> <p>Returns</p> <ul> <li><code>string</code>: The IP address or hostname of the server that the client will connect to.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the server's connection address\nstring serverAddress = NetworkManager.ConnectAddress;\nDebug.Log(\"Client will connect to server at address: \" + serverAddress);\n</code></pre>"},{"location":"api_reference/#framerate","title":"Framerate","text":"<p>Gets the current framerate of the application.</p> <ul> <li>Signature: <code>public static float Framerate { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>Framerate</code> property provides access to the application's current framerate. This value can be used to monitor the performance of the application in real-time, allowing developers to adjust settings or configurations based on performance metrics.</p> <p>Returns</p> <ul> <li><code>float</code>: The current framerate of the application.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the current application framerate\nfloat currentFramerate = NetworkManager.Framerate;\nDebug.Log(\"Current application framerate: \" + currentFramerate + \" FPS\");\n</code></pre>"},{"location":"api_reference/#cputimems","title":"CpuTimeMs","text":"<p>Gets the CPU time in milliseconds per frame.</p> <ul> <li>Signature: <code>public static float CpuTimeMs { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>CpuTimeMs</code> property provides access to the CPU time taken per frame, measured in milliseconds. This metric indicates the amount of time the CPU spends processing each frame, which is useful for monitoring and optimizing application performance.</p> <p>Returns</p> <ul> <li><code>float</code>: The CPU time per frame, in milliseconds.</li> </ul> <p>Example</p> <p>```csharp // Example of retrieving the CPU time per frame in milliseconds float cpuTimePerFrame = NetworkManager.CpuTimeMs; Debug.Log(\"CPU time per frame: \" + cpuTimePerFrame + \" ms\");</p>"},{"location":"http_lite/","title":"Overview","text":"<p>Http Lite is a simple simulation of <code>Express.js</code> and is one of the most useful features of the API. It can be easily used to request a route and receive a response from the server. Routes can also send responses to multiple clients beyond the one that originally requested the route.</p>"},{"location":"http_lite/#basic-usage","title":"Basic Usage","text":"<ol> <li>Import the <code>Http Lite</code> module with <code>using static Omni.Core.HttpLite;</code></li> <li>Register the routes on the <code>Awake</code> method or on the <code>Start</code> method, eg:</li> </ol> <p>Note</p> <p>Http Lite supports both asynchronous and synchronous operations, with all functions having their asynchronous versions.</p> <pre><code>Http.GetAsync(\"/login\", (res) =&gt;\n{\n    res.WriteString(\"Hello World!\");\n    res.Send();\n});\n</code></pre> <p>Tip</p> <p>Send() has overloads and optional arguments, allowing you to specify the recipient, delivery method, group, channel, cache, and more.</p> <ul> <li>Send with Target and Delivery Method (optional)</li> </ul> <pre><code>Http.GetAsync(\"/login\", (res) =&gt;\n{\n    res.WriteString(\"Hello World!\");\n    res.Send(HttpTarget.GroupMembers, DeliveryMode.ReliableOrdered); // Send the response to all group members &amp; deliver in reliable order\n});\n</code></pre> <p>Note</p> <p>When specifying that a route should send the response to clients other than the one that requested the route, you must ensure that these clients also register the route to receive the response.</p> <p>The default <code>HttpTarget</code> is <code>Self</code>, meaning that only the client that requested the route will receive the response.</p> <ul> <li>Request the route from the client.</li> </ul> <pre><code>async void RequestLogin()\n{\n    using var res = await Fetch.GetAsync(\"/login\");\n    string result = res.ReadString();\n    print(result);\n}\n</code></pre> <p>Here is the complete <code>example</code> if you want to test it. Attach this code to a script that is in the scene and press <code>Enter</code>.</p> <pre><code>void Start()\n{\n    Http.GetAsync(\"/login\", (res) =&gt;\n    {\n        res.WriteString(\"Hello World!\");\n        res.Send();\n    });\n}\n\nasync void RequestLogin()\n{\n    using var res = await Fetch.GetAsync(\"/login\");\n    string result = res.ReadString();\n    print(result);\n}\n\nprivate void Update()\n{\n    if (Input.GetKeyDown(KeyCode.Return))\n    {\n        RequestLogin();\n    }\n}\n</code></pre> <p>After pressing <code>Enter</code>, the console should display -&gt; \"Hello World\".</p> <p>Remember, this example uses the asynchronous method, which I always recommend using.</p> <p>Here is an example of the asynchronous version of <code>Post</code>.</p> <ul> <li>Register a <code>Post</code> route.</li> </ul> <pre><code>Http.PostAsync(\"/login\", (req, res) =&gt;\n{\n    // Read the username sent in the request\n    string username = req.ReadString()\n    // Send a response\n    res.WriteString(\"Your are logged in as \" + username);\n    res.Send();\n});\n</code></pre> <ul> <li>Request the route from the client.</li> </ul> <pre><code>using var res = await Fetch.PostAsync(\"/login\", req =&gt;\n{\n    req.WriteString(\"John Doe\");\n})\n\nstring result = res.ReadString();\nprint(result);\n</code></pre> <p>Here is the complete <code>example</code> if you want to test it. Attach this code to a script that is in the scene and press <code>Enter</code>.</p> <pre><code>void Start()\n{\n    Http.PostAsync(\"/login\", (req, res) =&gt;\n    {\n        // Read the username sent in the request\n        string username = req.ReadString();\n        // Send a response\n        res.WriteString(\"Your are logged in as \" + username);\n        res.Send();\n    });\n}\n\nasync void RequestLogin()\n{\n    using var res = await Fetch.PostAsync(\"/login\", req =&gt;\n    {\n        req.WriteString(\"John Doe\");\n    });\n\n    string result = res.ReadString();\n    print(result);\n}\n\nprivate void Update()\n{\n    if (Input.GetKeyDown(KeyCode.Return))\n    {\n        RequestLogin();\n    }\n}\n</code></pre> <p>Tip</p> <p>On the server side, it is possible to obtain the client that is requesting the route by adding a third argument when registering the route.</p> <pre><code>Http.PostAsync(\"/login\", (req, res, peer) =&gt; {});\nHttp.GetAsync(\"/login\", (res, peer) =&gt; {});\n</code></pre> <p><code>Peer</code> is a <code>NetworkPeer</code> object that represents the client that is requesting the route.</p>"},{"location":"rpc/","title":"Overview","text":"<p>RPCs (Remote Procedure Calls) are a standard software industry concept that allows methods to be called on objects that are not in the same executable. They enable communication between different processes or systems over a network.</p> <p>With RPCs, a server can invoke functions on a client, and similarly, a client can invoke functions on a server. This bi-directional communication allows for flexible and dynamic interactions between clients and servers, facilitating various operations such as requesting data, executing commands, and synchronizing states across different parts of a distributed system. RPCs provide a powerful mechanism for enabling remote interactions and enhancing the functionality of networked applications.</p>"},{"location":"rpc/#basic-usage","title":"Basic Usage","text":"<p>In Omni, RPCs work with any scripts that inherit from NetworkBehaviour, <code>ClientBehaviour</code>, <code>DualBehaviour</code>, or <code>ServerBehaviour</code>. The differences between them are as follows:</p> <ul> <li><code>NetworkBehaviour</code>: Used for objects instantiated with an identity.</li> <li><code>DualBehaviour</code>: Allows you to program both client and server logic in the same script. It cannot be instantiated and does not have an identity.</li> <li><code>ClientBehaviour</code> and <code>ServerBehaviour</code>: Used to program behaviors in separate scripts for client and server respectively. These cannot be instantiated and do not have an identity.</li> </ul>"},{"location":"rpc/#usage","title":"Usage...","text":"<p>An example of RPCs in the same script, handling both client and server logic:</p> <p>Note</p> <p>The method signatures can have up to three arguments for server methods and two arguments for client methods, with all arguments being optional.</p> <p>The full signature for server methods is:</p> <pre><code>[Server(id)]\nvoid name_of_method(DataBuffer buffer, NetworkPeer peer, int seqChannel) {}\n</code></pre> <p>The full signature for client methods is:</p> <pre><code>[Client(id)]\nvoid name_of_method(DataBuffer buffer, int seqChannel) {}\n</code></pre> <p>All arguments are optional, but they must be in the correct order and be of the correct type.</p> <p><code>without arguments:</code></p> <pre><code>[Server(id)]\nvoid name_of_method() {}\n</code></pre> <p>The signature for client methods is:</p> <pre><code>[Client(id)]\nvoid name_of_method() {}\n</code></pre> <p><code>one argument:</code></p> <pre><code>[Server(id)]\nvoid name_of_method(DataBuffer buffer) {}\n</code></pre> <p>The signature for client methods is:</p> <pre><code>[Client(id)]\nvoid name_of_method(DataBuffer buffer) {}\n</code></pre> <p><code>two arguments:</code></p> <pre><code>[Server(id)]\nvoid name_of_method(DataBuffer buffer, NetworkPeer peer) {}\n</code></pre> <p>The signature for client methods is:</p> <pre><code>[Client(id)]\nvoid name_of_method(DataBuffer buffer, int seqChannel) {}\n</code></pre> <p>Only the server method can have a <code>NetworkPeer</code> parameter.</p> <ul> <li>Let's send an RPC containing a simple message:</li> </ul> <pre><code>[Server(1)]\nvoid OnMsg_Server(DataBuffer buffer)\n{\n    print(\"received message: \" + buffer.ReadString() + \" from client\");\n}\n\n[Client(1)]\nvoid OnMsg_Client(DataBuffer buffer)\n{\n    print(\"received message: \" + buffer.ReadString() + \" from server\");\n}\n</code></pre> <p>In this example, we are invoking the RPC on the client that is connected to the server.</p> <pre><code>protected override void OnServerPeerConnected(NetworkPeer peer, Phase phase)\n{\n    if (phase == Phase.End)\n    {\n        DataBuffer buffer = new DataBuffer();\n        buffer.WriteString(\"Hello! (:)\");\n        Remote.Invoke(1, peer, buffer);\n    }\n}\n</code></pre> <p>Note</p> <ul> <li> <p>The <code>Remote.Invoke</code> method: This method is used by the server to     call RPCs on a connected client. It allows the server to request that the     client execute a specific method or operation remotely.</p> </li> <li> <p>The <code>Local.Invoke</code> method: This method is used by the client to     call RPCs on the server. It allows the client to request that the server     execute a specific method or operation remotely.</p> </li> </ul> <p>The <code>id</code> parameter is the ID of the RPC, used to identify the RPC on the server and client on the same object.</p> <p>Note</p> <p>The method <code>Invoke</code> has overloads and optional arguments, allowing you to specify the recipient, delivery method, group, channel, cache, and more.</p> <p>Here is the complete <code>example</code> if you want to test it. Attach this code to a script that is in the scene.</p> <pre><code>[Server(1)]\nvoid OnMsg_Server(DataBuffer buffer)\n{\n    print(\"received message: \" + buffer.ReadString() + \" from client\");\n}\n\n[Client(1)]\nvoid OnMsg_Client(DataBuffer buffer)\n{\n    print(\"received message: \" + buffer.ReadString() + \" from server\");\n}\n\nprotected override void OnServerPeerConnected(NetworkPeer peer, Phasphase)\n{\n    if (phase == Phase.End)\n    {\n        DataBuffer buffer = new DataBuffer();\n        buffer.WriteString(\"Hello! (:)\");\n        Remote.Invoke(1, peer, buffer);\n    }\n}\n</code></pre> <ul> <li>Send an RPC from the client to the server:</li> </ul> <pre><code>private void Update()\n{\n    if (Input.GetKeyDown(KeyCode.G))\n    {\n        DataBuffer buffer = new DataBuffer();\n        buffer.WriteString(\"Hello! (:)\");\n        Local.Invoke(1, buffer);\n    }\n}\n</code></pre> <p>Note</p> <p>Remember that we are inheriting from <code>DualBehaviour</code>, which implements the logic for both in the same script. <code>Local.Invoke</code> is not available when inheriting from <code>ServerBehaviour</code>, as it only contains server logic, and any client RPC signatures will be ignored. The same applies to <code>ClientBehaviour</code>, where <code>Remote.Invoke</code> is not available because it only handles client logic, and any server RPC signatures will be ignored;</p> <p><code>NetworkBehaviour</code> should be used for objects that are instantiated on the network and have an identity.</p> <ul> <li>Let's create a messaging chat to clearly demonstrate the use of RPCs. This time, we will keep the logic in separate scripts.</li> </ul> <p>Create a <code>ChatServer</code> script that inherits from <code>ServerBehaviour</code> and create a <code>ChatClient</code> script that inherits from <code>ClientBehaviour</code>.</p> <p><code>Server-Side</code>:</p> <pre><code>public class ChatServer : ServerBehaviour\n{\n    // eg 1(example): Message without validation\n    [Server(1)]\n    void OnChat_Server(DataBuffer buffer, NetworkPeer peer)\n    {\n        // Server resend the message to all clients\n        Remote.Invoke(1, peer, buffer, Target.All, DeliveryMode.ReliableOrdered);\n    }\n\n    // eg(example): Message with simple validation on server\n    [Server(1)]\n    void OnChat_Server(DataBuffer buffer, NetworkPeer peer)\n    {\n        var nBuffer = new DataBuffer();\n        // Re-send the message to all clients\n        string message = buffer.ReadString();\n        if (message.Contains(\"Hello\"))\n        {\n            message = \"*****\";\n        }\n\n        nBuffer.WriteString(message);\n        Remote.Invoke(1, peer, nBuffer, Target.All, DeliveryMode.ReliableOrdered);\n    }\n}\n</code></pre> <p>Warning</p> <p>You cannot have multiple RPC's with the same identification ID in the same script.</p> <p><code>Client-Side</code>:</p> <pre><code>public class ChatClient : ClientBehaviour\n{\n    [Client(1)]\n    void OnChat_Client(DataBuffer buffer)\n    {\n        print(buffer.ReadString());\n    }\n\n    private void Update()\n    {\n        if (Input.GetKeyUp(KeyCode.Space))\n        {\n            DataBuffer buffer = new DataBuffer();\n            buffer.WriteString(\"Hello World!\");\n            Local.Invoke(1, buffer);\n        }\n    }\n}\n</code></pre>"},{"location":"rpc/#network-behaviour","title":"Network Behaviour","text":"<p>When using an instantiated object with an identity, the scripts must inherit from <code>NetworkBehaviour</code>. The RPCs function exactly the same way, except thatthey do not take the <code>Peer</code> argument.</p> <p>eg: <code>Remote.Invoke(1, nBuffer, Target.All, DeliveryMode.ReliableOrdered);</code></p>"},{"location":"serialization/","title":"Overview","text":"<p>Omni is capable of serializing various types of data, including primitives, complex classes, structures, dictionaries, and more. Omni offers two types of serialization: JSON-based and binary-based serialization.</p> <p>All network operations are performed using the <code>DataBuffer</code> object, which represents a buffer of data to be sent over the network.</p>"},{"location":"serialization/#basic-usage-of-databuffer","title":"Basic Usage of DataBuffer","text":"<ul> <li>Basic serialization</li> </ul> <pre><code>void Start()\n{\n    DataBuffer buffer = new DataBuffer(1024); // Size of the buffer in bytes,     this argument is optional, the default size is 32768\n    buffer.Write(10);\n    buffer.WriteString(\"Hello World!\");\n}\n</code></pre> <ul> <li>Using JSON serialization with <code>DataBuffer</code></li> </ul> <pre><code>public class Player\n{\n    public string name;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.WriteAsJson(new Player());\n}\n</code></pre> <ul> <li>Using binary serialization with <code>DataBuffer</code></li> </ul> <pre><code>[MemoryPackable]\npublic partial class Player\n{\n    public string health;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.WriteAsBinary(new Player());\n}\n</code></pre> <ul> <li>Complex serialization with <code>DataBuffer</code></li> </ul> <pre><code>[MemoryPackable]\npublic partial class Player\n{\n    public string health;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.Write(3287382);\n    buffer.WriteAsBinary(new Player());\n    buffer.WriteAsJson(new Player());\n    buffer.WriteString(\"Hello World!\");\n}\n</code></pre> <p>Warning</p> <p>When sending a <code>DataBuffer</code>, you will always receive a <code>DataBuffer</code> in response; it is not possible to send and receive data in any other way without using a <code>DataBuffer</code>, as all operations utilize it internally. You must also ensure that the reading and writing occur in the same order.</p> <p>If you write an <code>integer</code> followed by a <code>string</code>, you must read an <code>integer</code> followed by a <code>string</code>. Never attempt to read the data in an order different from the one in which it was written, as this will result in incorrect data retrieval and potential errors.</p> <p>Omni uses the Newtonsoft.Json library for JSON serialization.</p> <p>For binary serialization, Omni employs the MemoryPack library.</p> <p>For more details, please refer to the documentation:</p> <ul> <li>JSON Serialization: Newtonsoft.Json Documentation</li> <li>Binary Serialization: MemoryPack GitHub Repository</li> </ul>"},{"location":"spawning/","title":"Spawning","text":""},{"location":"spawning/#overview","title":"Overview","text":"<p>Omni supports spawning objects on both the server and client, providing several methods for network object instantiation. In this guide, we\u2019ll walk you through the available options, from the simplest to the most advanced approaches, enabling you to choose the best method based on your project\u2019s requirements.</p> <p>Each method allows for a different level of control over networked objects, from basic automatic spawning to more complex, customizable instantiation processes.</p>"},{"location":"spawning/#simple-instantiation","title":"Simple Instantiation","text":"<p>The Network Object Spawner component provides a quick and efficient way to instantiate networked objects, making it ideal for prototyping stages. This component simplifies the process by automatically handling the instantiation of both prefabs and scene objects over the network. </p> <p>With Network Object Spawner, you can set up networked objects with minimal configuration, allowing you to focus on testing gameplay and mechanics rather than complex network setups.</p> <ul> <li>Add the <code>Network Object Spawner</code> component to any game object in your scene.</li> </ul> Field Description Local Player A <code>NetworkIdentity</code> reference for the object that will be controlled by the local player. This object will receive input and commands directly from the local player. Objects to Spawn A list of <code>NetworkIdentity</code> references for objects to be managed by the server. These objects will be instantiated over the network and controlled by the server. <p>Using this setup, the <code>Network Object Spawner</code> manages instantiation and synchronization, simplifying networked spawning for both player-controlled and server-managed objects.</p> <p>Tip</p> <p>You can add either a prefab or a scene object to the Local Player or Objects to Spawn list, depending on your project\u2019s requirements.</p>"},{"location":"spawning/#manual-instantiation","title":"Manual Instantiation","text":"<p>If you want to instantiate a networked object manually in a straightforward way, here are some examples to guide you. Manual instantiation provides you with more control over when and where the networked object appears in the scene, ideal for scenarios where specific logic or conditions dictate object creation. </p> <p>Follow these examples to quickly and easily get started with manual instantiation of networked objects in your project.</p> <p>First example:</p> <pre><code>   // Cache to store all spawn-related messages.\n   private DataCache m_SpawnCache = new DataCache(CachePresets.ServerNew);\n\n   protected override void OnServerPeerConnected(NetworkPeer peer, Phase phase)\n   {\n       // Ensure actions occur only after the client is fully connected and authenticated.\n       if (phase == Phase.End) // Phase.End: Indicates the client is authenticated and ready for network interactions\n       {\n           // Retrieve the first registered prefab from the NetworkManager\u2019s prefab list. \n           // Note: you can also use:\n           // var prefab = NetworkManager.GetPrefab(\"PrefabName\");\n           NetworkIdentity prefab = NetworkManager.GetPrefab(0);\n\n           // Spawn the prefab for the connected peer and pass the spawn cache\n           prefab.Spawn(peer, dataCache: m_SpawnCache);\n\n           // Send the cached spawn data to the connected peer, allowing late-joining players to \n           // receive all relevant spawn information and ensuring they have a consistent game state.\n           m_SpawnCache.SendToPeer(peer);\n       }\n   }\n</code></pre> <p>Tip</p> <ul> <li><code>NetworkManager.GetPrefab</code> offers two overloads: one for retrieving a prefab by its name and another for accessing a prefab by its index in the registered prefab list.</li> <li><code>prefab.Spawn</code> offers two overloads and optional arguments to control the spawn process.</li> </ul> <p>Check de API reference for more details.</p>"}]}