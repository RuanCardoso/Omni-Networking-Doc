{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#overview","title":"Overview","text":"<p>Omni Networking is a comprehensive solution designed to support high-performance multiplayer game development in <code>Unity</code>. With a wide array of features, <code>Omni</code> provides robust tools to handle various networking needs essential for modern games. Below is an <code>overview</code> of Omni's core functionalities:</p> <p>Core Functionalities</p> Feature Description Database Management Supports relational databases with a built-in <code>ORM</code>, enabling scalable, efficient, and secure data operations tailored for multiplayer environments. RouteX A flexible routing system inspired by Express.js, allowing developers to define and manage network routes efficiently. It enables organized handling of network requests and responses, making it ideal for complex multiplayer interactions. RPC (Remote Procedure Call) Allows methods to be called across clients and servers, enabling synchronized actions and data sharing in multiplayer environments. Making it easy to call functions remotely. gRPC (Global Remote Procedure Call) Allows methods to be called across clients and servers, enabling synchronized actions and data sharing in multiplayer environments. Making it easy to call functions remotely. Port Forwarding Facilitates NAT traversal and opens network ports using protocols like <code>PMP</code> and <code>UPnP</code>, ensuring seamless connectivity for multiplayer sessions. Network Variables Enables automatic synchronization of properties between server and clients without the need for custom messages or RPCs, streamlining data consistency across networked players. Binary Serialization Utilizes the <code>MemoryPack</code> library for efficient binary data serialization, minimizing data size for faster transmission and optimized network performance. JSON Serialization Uses the <code>Json.NET (Newtonsoft)</code> library for flexible and reliable JSON data serialization, ensuring compatibility with third-party services and smooth data interchange. Compression Leverages <code>Brotli</code> and <code>LZ4</code> algorithms to reduce data size, optimizing bandwidth usage and improving transmission speed for smoother network performance. Cryptography Utilizes <code>AES</code> and <code>RSA</code> encryption algorithms to secure data transmission, ensuring protection of sensitive information across the network. <p><code>Omni</code> supports only versions <code>2021.3 and above</code>, as it utilizes the latest APIs available in .NET Standard 2.1 and beyond to achieve the highest possible performance.</p> <p>Compatibility Table:</p> Unity Version Compatibilidade Unity 2021.3 (LTS) \u2705 Unity 2022.3 (LTS) \u2705 Unity 6 (LTS) \u2705 <p>Warning</p> <p>Versions not listed in the compatibility table may not be fully supported and could exhibit unexpected behavior. For the most reliable experience, please refer to the Releases page to verify compatibility with the latest available versions.</p>"},{"location":"#installation","title":"Installation","text":"<p>Warning</p> <p>Before getting started, it's important to be aware that Omni includes some dependencies by default:</p> <ul> <li>Newtonsoft Json</li> <li>Memory Pack</li> <li>UniTask</li> <li>DOTween</li> <li>Database modules, among others.</li> </ul> <p>Make sure to remove these dependencies from your project if they already exist. For this reason, I recommend always starting with a new project to avoid any conflicts.</p> <ol> <li>Download the latest Omni package from the Releases.</li> <li>Import the package into your project.</li> </ol>"},{"location":"#setup","title":"Setup","text":"<p>Note</p> <p>After importing the package and waiting for the recompilation, some macros are automatically defined:</p> <ul> <li><code>OMNI_RELEASE</code></li> <li><code>OMNI_DEBUG</code></li> <li><code>OMNI_SERVER</code> &lt;- is defined when the target platform is set to <code>DEDICATED SERVER</code> in the <code>Build Settings</code>.</li> </ul> <p>You can use these macros to switch between release and debug builds, by default the <code>OMNI_DEBUG</code> macro is defined.</p> <pre><code>#if OMNI_RELEASE\nprint(\"You're in release mode\");\n#endif\n\n#if OMNI_DEBUG\nprint(\"You're in debug mode\");\n#endif\n\n#if OMNI_SERVER\nprint(\"You're in server mode\");\n#endif\n</code></pre> <p>You can use these macros to strip the code from the build process for security reasons.</p> <pre><code>#if OMNI_SERVER\n// sensitive server code\n#else\n// Client code\n#endif\n</code></pre> <p>Omni using's:</p> <pre><code>using Omni.Core;\nusing static Omni.Core.RouteX;\n</code></pre> <ol> <li>Go to the Unity Navigation Bar and select <code>Omni Networking</code>.</li> <li>Click the <code>Setup</code> menu item.</li> </ol> <p>A GameObject named <code>Network Manager</code> will be created in the scene. This object is responsible for the connection and contains all the network settings.</p> <p>Warning</p> <p>The <code>Network Manager</code> object must be in the scene for Omni to function properly and not should be destroyed or renamed.</p> <p>Tip</p> <p>The <code>Network Manager</code> object has two child objects that can optionally host client and server scripts. It\u2019s optional to place scripts on these objects. When scripts are assigned to these child objects, Unity automatically separates them during the build process. In <code>release</code> mode, server scripts won\u2019t run in the client build, and vice versa.</p> <p>Note: This approach doesn\u2019t strip the code; it merely prevents execution by removing the objects from the scene at build time. To strip the code, consider using the <code>OMNI_RELEASE</code>, <code>OMNI_DEBUG</code>, and <code>OMNI_SERVER</code> macros.</p> <ol> <li>Select the <code>Network Manager</code> object in the scene to view the network settings.</li> </ol> Option Description <code>Public IPv4</code> The public IPv4 address of the client <code>Public IPv6</code> The public IPv6 address of the client"},{"location":"#modules","title":"Modules","text":"Modules Description <code>Console Module</code> Allows sending and receiving commands in the console when the build is for a server. <code>Match Module</code> Allows matchmaking, creating, joining, and deleting groups, among other features. <code>Tick Module</code> Allows the use of a tick-based system for sending messages and other tick-based operations. <code>Sntp Module</code> Provides a high-precision synchronized clock between all clients and the server."},{"location":"#connection-settings","title":"Connection Settings","text":"Option Description <code>Server Port</code> The port number on which the server listens for incoming connections. <code>Client Port</code> The port number on which the client listens for incoming connections. Option Description <code>Host Address</code> The IP address or hostname of the server to which the client will connect. <code>Port</code> The port number on which the server is listening and which will be used for the connection."},{"location":"#miscellaneous","title":"Miscellaneous","text":"Option Description <code>Tick Rate</code> The rate at which the game loop processes updates, measured in ticks per second. <code>Pool Capacity</code> Represents, in bytes, the size of the buffer <code>(byte[])</code> internally allocated for each <code>DataBuffer</code>. <code>Pool Size</code> Specifies the number of <code>DataBuffer</code> instances pre-allocated in the pool, ready for use. <code>Max Fps On Client</code> The maximum frame rate that the client will attempt to render, measured in frames per second. <code>Auto Start Server</code> Whether the server should automatically start when the application launches. <code>Auto Start Client</code> Whether the client should automatically start when the application launches. <code>Use UTF-8 Encoding</code> Whether to use UTF-8 encoding for text data in the application. <code>Use Binary Serialization</code> Coming soon..... DON'T USE IT YET! Experimental feature. <code>Use Unaligned Memory</code> Whether to allow unaligned memory access, which may affect performance and compatibility. <code>Run In Background</code> Whether the application should continue running while in the background, even when not in focus."},{"location":"#permissions","title":"Permissions","text":"Option Description <code>Allow NetVar's From Client</code> Determines whether client-side changes to network variables are permitted, allowing clients to modify networked variables directly. <code>Allow Across Group Message</code> Allows messages to be sent across different network groups, enabling communication between distinct groups in the network."},{"location":"#registered-prefabs","title":"Registered Prefabs","text":"<p>This list is used to automatically instantiate network objects. When a network object is instantiated by name or indexer, the object will be looked up in this list and instantiated automatically. Remember, manual instantiation is also available, and using this list is not required.</p>"},{"location":"#transporter-settings","title":"Transporter Settings","text":"<p>The Transporter Settings section allows you to configure various network transport parameters, including disconnection timeout, network event processing per frame, lag simulation, channel setup, IPv6 support, max connections, ping intervals, and more. Available options may vary based on the selected transporter.</p> <p>Currently, two transporters are supported: Lite Transporter and KCP Transporter, with additional options planned for future releases.</p> Transporter ReliableOrdered Unreliable ReliableUnordered Sequenced ReliableSequenced Browser Compatibility Lite Transporter \u2705 \u2705 \u2705 \u2705 \u2705 \u274c Kcp Transporter \u2705 \u2705 \u274c \u274c \u274c \u274c Web Socket Transporter \u2705 \u274c \u274c \u274c \u274c \u23f3 Available Soon <p>Danger</p> <p>The KCP Transporter is currently experimental and may contain unresolved issues. Use it with caution and consider thoroughly testing for stability in your specific use case.</p> <p>Note</p> <p>By default, Omni utilizes the Lite Transporter for network operations. To switch to a different transporter, follow these steps:</p> <ol> <li>Remove the Lite Transporter: In your scene, locate the <code>Network Manager</code> object. Select it, and remove the <code>Lite Transporter</code> component from this object.</li> <li>Add the Desired Transporter: Once the Lite Transporter is removed, add the component of your preferred transporter to the <code>Network Manager</code> object.</li> </ol> <p>This configuration enables you to tailor network transport settings to suit the specific requirements of your project, ensuring optimal compatibility and performance.</p> <p>Warning</p> <p>Some properties or functions may be unavailable for certain transporters. If an incompatible option is used, an error message will appear to inform you of the mismatch.</p> <p>For detailed information on each transporter and their specific features, consult the respective documentation:</p> <ul> <li>LiteNetLib Documentation</li> <li>KCP Transporter (kcp2k) Documentation</li> </ul>"},{"location":"#known-issues","title":"Known Issues","text":"<p>Bug</p> <p>Public IP Configuration Required: Omni relies on the correct IP configuration in the <code>Public IP</code> field of the <code>Network Manager</code>. When sharing your project, this field may display an incorrect IP address from another user. To update it, open the context menu of the <code>Network Manager</code> script, press Get External IP, and Omni will automatically update the field to reflect your current IP address.</p> <p>Bug</p> <p>Omni Package Installation Issues: If you experience problems during the Omni package installation, such as Unity freezing or crashing, and the necessary macros are not defined, you may need to manually reset the macros. To do this, go to the root folder of the Omni package and delete the hidden file that begins with <code>omni_macros</code>. Ensure hidden files are visible in your file explorer to locate this file.</p>"},{"location":"#communication-structure","title":"Communication Structure","text":"<p>The Omni framework is structured around four foundational classes designed for general communication. These classes implement methods and properties that simplify and expedite multiplayer functionalities, making the process both efficient and straightforward. Additionally, a \"low-level\" class is available for advanced communication, which should be utilized in contexts where restrictions or limitations apply, offering finer control for specialized cases.</p> <p>The Omni framework currently utilizes four base classes, each designed for different networking roles within the multiplayer structure. These classes include:</p> <ul> <li><code>NetworkBehaviour</code></li> <li><code>ServerBehaviour</code></li> <li><code>ClientBehaviour</code></li> <li><code>DualBehaviour</code></li> </ul> <p>Each class serves a unique purpose in managing networked objects and handling server or client logic.</p>"},{"location":"#networkbehaviour","title":"<code>NetworkBehaviour</code>","text":"<ul> <li>Designed for networked objects with a <code>NetworkIdentity</code>.</li> <li>Primarily used for objects that require a unique identity within the network, such as player avatars or specific interactable objects in the game world.</li> <li>This class provides essential methods and properties to facilitate identity-based communication and synchronization across the network.</li> </ul> <p>Warning</p> <p>Network objects that have an <code>NetworkIdentity</code> must be instantiated to be registered with the network. Direct creation without instantiation will not register the object, and the <code>NetworkBehaviour</code> don't work.</p>"},{"location":"#serverbehaviour","title":"<code>ServerBehaviour</code>","text":"<ul> <li>Suited for networked objects that do not require a <code>NetworkIdentity</code>.</li> <li>Manages logic exclusively on the server side.</li> <li>Ideal for general server tasks, such as managing game state or processing server-side events.</li> <li>Simplifies server-side programming by abstracting client-specific requirements, allowing a focus on server logic.</li> </ul>"},{"location":"#clientbehaviour","title":"<code>ClientBehaviour</code>","text":"<ul> <li>Suited for networked objects that do not require a <code>NetworkIdentity</code>.</li> <li>Used for managing client-specific logic and interactions.</li> <li>Ideal for general client tasks, such as login, character selection, or UI management, etc.</li> <li>Simplifies client-side programming by abstracting server-specific requirements, allowing a focus on client logic.</li> </ul>"},{"location":"#dualbehaviour","title":"<code>DualBehaviour</code>","text":"<ul> <li>Combines <code>ClientBehaviour</code> and <code>ServerBehaviour</code> to handle both client and server logic within a single script.</li> <li>Best suited for cases where a unified approach to client and server operations is necessary, reducing redundancy.</li> <li>Enables shared logic across client and server while maintaining the separation of client-exclusive and server-exclusive tasks.</li> </ul> <p>Summary Table</p> Class Identity Requirement Logic Scope Use Case <code>NetworkBehaviour</code> Requires a <code>NetworkIdentity</code> General network For networked objects with unique identifiers(<code>NetworkIdentity</code>) <code>ServerBehaviour</code> No <code>NetworkIdentity</code> Server-side only For server-exclusive logic without identity dependencies. <code>ClientBehaviour</code> No <code>NetworkIdentity</code> Client-side only For client-specific logic, optimized for local processing. <code>DualBehaviour</code> No <code>NetworkIdentity</code> Client and Server Combines client and server logic within a single script. <p>This structured approach with these base classes simplifies multiplayer development, enabling clear separation of client and server responsibilities while providing flexibility for objects with and without identities.</p> <p>Warning</p> <p>Objects with <code>ClientBehaviour</code>, <code>ServerBehaviour</code>, or <code>DualBehaviour</code> scripts attached cannot be spawned and not support <code>NetworkIdentity</code>, as they are intended for use with scene objects only. These classes should be used exclusively for objects that exist in the scene from the start, rather than dynamically spawned instances. For this case use the <code>NetworkBehaviour</code> class with a <code>NetworkIdentity</code> attached.</p> <p>Warning</p> <p>All network operations, including RPC's, events, and network variables, require scripts to inherit from one of these four classes (<code>NetworkBehaviour</code>, <code>ServerBehaviour</code>, <code>ClientBehaviour</code>, or <code>DualBehaviour</code>). Without this inheritance, network functionality will not be available in the script.</p>"},{"location":"#network-identity","title":"Network Identity","text":"<p>The <code>NetworkIdentity</code> component is at the heart of the Omni networking high-level API. It controls a game object's unique identity on the network, and it uses that identity to make the networking system aware of the game object.</p> <p>Warning</p> <p>It is important to note that Omni does not support <code>NetworkIdentity</code> on nested GameObjects. Otherwise, Omni will emit an error. To avoid this, ensure your parent <code>GameObject</code> is the only <code>GameObject</code> in the stack with a <code>NetworkIdentity</code> component. Child GameObjects can access the parents' <code>NetworkIdentity</code> component via <code>Identity</code> property inhirited from <code>NetworkBehaviour</code>.</p> <p>Network Identity Properties</p> Property Type Description <code>IdentityId</code> <code>int</code> A unique identifier for the networked object. This ID is assigned by the server to track the object across all clients. <code>IsServer</code> <code>bool</code> Indicates if the object is running on the server side. <code>false</code> if the object is running on the client side. <code>IsClient</code> <code>bool</code> Indicates if the object is running on the client side. <code>true</code> if the object is running on the server side. <code>IsLocalPlayer</code> <code>bool</code> Specifies if this object represents the local player. <code>true</code> if the object is owned by the local client. <code>IsServerOwner</code> <code>bool</code> Indicates if the server has ownership of this object. <code>true</code> if the server is the primary controller of this object. <code>LocalPlayer</code> <code>NetworkIdentity</code> A static reference to the local player instance, set on the client only. Assigned when the local player is spawned. <code>Owner</code> <code>NetworkPeer</code> The owner of this object. Available only on the server, and returns <code>NetworkManager.LocalPeer</code> on the client. <code>IsRegistered</code> <code>bool</code> Indicates whether this <code>NetworkIdentity</code> is registered on the network. <p>Warning</p> <p><code>NetworkIdentity.LocalPlayer</code> is only available on the client side. Assigned when the prefab have the tag <code>Player</code>, contain <code>Player</code> in the tag, or include <code>Player</code> in the prefab name, otherwise it will be <code>null</code>.</p> <p>Example of valid prefab name: </p> <ul> <li><code>RuanCharacterPlayer</code></li> <li><code>JuniorPlayer</code></li> </ul> <p>Example of valid prefab tag: </p> <ul> <li><code>Player</code></li> <li><code>RuanTagPlayer</code></li> <li><code>JuniorTagPlayer</code></li> </ul>"},{"location":"#service-locator-pattern","title":"Service Locator Pattern","text":"<p>The Service Locator pattern is a design pattern that provides a centralized registry or \"locator\" for retrieving instances of services or dependencies at runtime. This pattern allows for flexible dependency management and reduces the coupling between objects, making it ideal for complex applications like multiplayer games.</p> <p>Key Benefits of the Service Locator Pattern</p> <ul> <li>Centralized Access to Services: By acting as a central registry, the Service Locator allows different parts of the application to access services without tightly coupling dependencies.</li> <li>Flexible and Scalable: Services can be registered, replaced, or removed dynamically, providing flexibility for handling different networked components and systems in a multiplayer environment.</li> <li>Reduced Dependency on Singleton: Unlike the Singleton pattern, which can introduce issues in multiplayer setups (such as unwanted global state persistence), the Service Locator keeps services manageable and avoids potential conflicts.</li> <li>Improved Testing and Maintainability: The pattern facilitates testing and maintainability by allowing services to be swapped or mocked, which is crucial in a large multiplayer codebase.</li> </ul>"},{"location":"#service-locator-vs-singleton","title":"Service Locator vs. Singleton","text":"<p>While the Singleton pattern is commonly used to ensure only one instance of a class exists, it can lead to issues in multiplayer environments. Singletons often hold global state, which can interfere with networked instances and create unpredictable behavior, especially when managing player-specific data.</p> <p>Tip</p> <p>Omni recommends using the Service Locator pattern instead of Singletons for multiplayer development. The Service Locator provides better control over dependencies and avoids the pitfalls of global state inherent in Singletons, making it a more stable choice for complex networked systems.</p>"},{"location":"#usage-guide","title":"Usage Guide","text":"<p>By default, any script that inherits from a network class(<code>NetworkBehaviour</code>, <code>ServerBehaviour</code>, <code>ClientBehaviour</code>, <code>DualBehaviour</code> or <code>ServiceBehaviour</code>) is automatically registered in the Service Locator. This registration simplifies access to network services across your game's architecture. </p> <p>Service Naming and Customization</p> <ul> <li>Automatic Naming: Each service name is assigned automatically upon registration, based on the script's name.</li> <li>Customizable Names: You can modify the default service name directly in the Unity Inspector, allowing flexibility in organizing and identifying services as needed.</li> </ul> <p>Types of Service Locators in Omni</p> <p>Omni provides two types of Service Locators to manage service instances effectively within different scopes:</p> <ol> <li> <p>Global Service Locator: A shared Service Locator accessible across all networked instances. This global registry is ideal for managing universal services that need to be accessed by multiple objects or systems throughout the game.</p> </li> <li> <p>Local Service Locator: Each <code>NetworkIdentity</code> has its own local Service Locator, unique to that networked identity. allows you to retrieve specific services within the same identity, providing fine control over dependencies and enabling isolated management of services per networked object.</p> </li> </ol> <p>With this dual Service Locator approach, Omni offers a flexible, scalable structure that enhances dependency management in multiplayer environments, ensuring services are easily accessible while maintaining clear separation between global and local contexts.</p> Global Service LocatorLocal Service Locator <pre><code>// Example usage of the Global Service Locator\npublic class UIManager : ServiceBehaviour\n{ \n\n}\n\npublic class LoginManager : ClientBehaviour \n{ \n\n}\n\npublic class Player : NetworkBehaviour\n{\n   void Example()\n   {\n      // Accessing the `LoginManager` from the Global Service Locator\n      LoginManager loginManager = NetworkService.Get&lt;LoginManager&gt;();\n\n      // Accessing the `UIManager` from the Global Service Locator with a custom name\n      UIManager uiManager = NetworkService.Get&lt;UIManager&gt;(\"MyUIManager\");\n   }\n}\n</code></pre> <pre><code>// Example usage of the Local Service Locator\n// This script must be attached to the same networked object(`NetworkIdentity`).\npublic class WeaponManager : NetworkBehaviour\n{ \n\n}\n\npublic class PlayerManager : NetworkBehaviour\n{\n   void Example()\n   {\n      // Accessing the `WeaponManager` from the Local Service Locator using my own identity\n      WeaponManager weaponManager = Identity.Get&lt;WeaponManager&gt;();\n   }\n}\n</code></pre> <p>Note</p> <p>The service locator can find services regardless of their depth within the hierarchy, ensuring accessibility even in deeply nested objects.</p> <p>Warning</p> <p>If you have multiple instances of the same script type across different objects in the hierarchy (e.g., multiple <code>WeaponManager</code> scripts, one for each weapon), you should rename the service in the Inspector for each instance. Use a named lookup to retrieve the specific instance you need, such as: </p> <ul> <li><code>Identity.Get&lt;WeaponManager&gt;(\"GlockManager\");</code></li> <li><code>Identity.Get&lt;WeaponManager&gt;(\"MeeleManager\");</code></li> </ul> <p>An exception will be thrown if the service is not found or if multiple instances of the same type have the same name.</p> <p>Tip</p> <p>The Service Locator is designed to be fast and efficient, with minimal performance cost, unlike <code>GetComponent</code>, making it suitable for frequent use.</p> <p>See the API Reference for more information about the Service Locator and its usage.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#network-manager","title":"Network Manager","text":"<p>The <code>NetworkManager</code> class is the core component of the Omni Networking library for Unity. It provides a framework for managing network operations, including client-server communication, synchronization, and data transmission.</p> <p>The <code>NetworkManager</code> class is responsible for handling the initialization, configuration, and management of the network environment. It acts as a central hub for network-related operations, such as connecting to a server, handling client-server communication, and managing network events.</p>"},{"location":"api_reference/#methods","title":"Methods","text":""},{"location":"api_reference/#clearcaches","title":"ClearCaches","text":"<p>Clears all global caches, removing all entries from both append and overwrite cache collections.</p> <ul> <li>Signature: <code>public static void ClearCaches()</code></li> </ul> <p>Description</p> <p>The <code>ClearCaches</code> method removes all entries in the global append and overwrite cache collections. This method is useful for freeing up resources by clearing all cached data across the network, ensuring a clean state.</p> <p>Example</p> <pre><code>// Example of clearing all global caches\nNetworkManager.Server.ClearCaches();\nDebug.Log(\"All global caches have been cleared.\");\n</code></pre>"},{"location":"api_reference/#destroyallcaches","title":"DestroyAllCaches","text":"<p>Destroys all caches associated with the specified <code>NetworkPeer</code>, removing both global and overwrite caches marked for auto-destruction.</p> <ul> <li>Signature: <code>public static void DestroyAllCaches(NetworkPeer peer)</code></li> </ul> <p>Description</p> <p>The <code>DestroyAllCaches</code> method removes all cache entries associated with the given <code>NetworkPeer</code> that are marked for auto-destruction (<code>AutoDestroyCache</code>). This includes caches from both global append and global overwrite collections. If any cache entry fails to be removed, an error is logged.</p> <p>Parameters</p> Parameter Type Description <code>peer</code> <code>NetworkPeer</code> The network peer whose associated caches are to be destroyed. <p>Example</p> <pre><code>// Example of destroying all caches for a specific peer\nNetworkPeer clientPeer = GetClientPeer(); // Hypothetical method to get a client peer\nNetworkManager.Server.DestroyAllCaches(clientPeer);\nDebug.Log($\"Destroyed all auto-destroy caches for peer {clientPeer.Id}\");\n</code></pre>"},{"location":"api_reference/#deletecache","title":"DeleteCache","text":"<p>Deletes a cache entry based on the provided <code>DataCache</code> and optional <code>groupId</code>, or a <code>DataCache</code> associated with a specific <code>NetworkPeer</code>.</p> <ul> <li>Signature:</li> <li><code>public static void DeleteCache(DataCache dataCache, int groupId = 0)</code></li> <li><code>public static void DeleteCache(DataCache dataCache, NetworkPeer peer, int groupId = 0)</code></li> </ul> <p>Description</p> <p>The <code>DeleteCache</code> methods remove cache entries based on the provided <code>DataCache</code> details. Depending on the cache's <code>Mode</code>, this can involve removing global, group-specific, or peer-specific caches, with additional conditions to check if the <code>DataCache.Id</code> and <code>DataCache.Mode</code> are set correctly. These methods ensure the removal of specified caches, either by targeting a particular group (<code>groupId</code>) or by associating it with a specific peer (<code>NetworkPeer</code>).</p> <p>Parameters</p> Parameter Type Description <code>dataCache</code> <code>DataCache</code> The data cache to delete, which includes mode and ID for the targeted cache entry. <code>groupId</code> <code>int</code> The ID of the group to which the cache belongs (optional, default is <code>0</code>). <code>peer</code> <code>NetworkPeer</code> The peer associated with the cache, for peer-specific cache deletion. <p>Overloads</p> DeleteCache (DataCache dataCache, int groupId = 0)DeleteCache (DataCache dataCache, NetworkPeer peer, int groupId = 0) <p>Deletes a cache entry in a specific group or globally based on the provided <code>DataCache</code> and <code>groupId</code>.</p> Parameter Type Description <code>dataCache</code> <code>DataCache</code> The data cache to delete. <code>groupId</code> <code>int</code> The ID of the group to which the cache belongs. Example <pre><code>// Example of deleting a cache entry in a specific group\nDataCache cacheToDelete = new DataCache(CachePresets.ServerNew);\nNetworkManager.Server.DeleteCache(cacheToDelete, groupId: 5);\n</code></pre> <p>Deletes a cache entry for a specific peer or group based on the provided <code>DataCache</code>, <code>NetworkPeer</code>, and optional <code>groupId</code>.</p> Parameter Type Description <code>dataCache</code> <code>DataCache</code> The data cache to delete. <code>peer</code> <code>NetworkPeer</code> The peer associated with the cache. <code>groupId</code> <code>int</code> The ID of the group to which the cache belongs. Example <pre><code>// Example of deleting a peer-specific cache entry\nDataCache cacheToDelete = new DataCache(CachePresets.ServerNew);\nNetworkManager.Server.DeleteCache(cacheToDelete, peer, groupId: 3);\n</code></pre>"},{"location":"api_reference/#invokeserver-by-instance","title":"Invoke(Server) by Instance","text":"<p>Invokes a Remote Procedure Call (RPC) on clients, targeting a specific network identity and script instance by their IDs, with customizable options for target, delivery mode, grouping, and sequencing.</p> <ul> <li>Signature:</li> <li><code>public static void Invoke(byte msgId, NetworkPeer peer, int identityId, byte instanceId, SyncOptions options)</code></li> <li><code>public static void Invoke(byte msgId, NetworkPeer peer, int identityId, byte instanceId, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>Invoke</code> method allows the server to execute a specific RPC on clients by targeting a <code>NetworkIdentity</code> and a specific script instance associated with that identity. The <code>identityId</code> identifies the object, while <code>instanceId</code> specifies the exact script instance on that object that should receive the RPC. This function provides options for message delivery such as buffer, target recipients, delivery reliability, grouping, and sequencing.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The unique ID of the <code>NetworkIdentity</code> that will receive the RPC. <code>instanceId</code> <code>byte</code> The ID of the script instance on the <code>NetworkIdentity</code> that will receive the RPC. <code>options</code> <code>SyncOptions</code> A set of options for synchronization (used in the first overload). <code>buffer</code> <code>DataBuffer</code> Optional data buffer to send. <code>target</code> <code>Target</code> Specifies the target for the RPC, such as all clients or a specific peer (default is <code>All</code>). <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code> (default), <code>Unreliable</code>, etc. <code>groupId</code> <code>int</code> ID for grouping related messages together (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Cache option for the data being sent (default is <code>DataCache.None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing to manage order consistency across channels (default is <code>0</code>). <p>Overloads</p> Invoke (byte msgId, NetworkPeer peer, int identityId, byte instanceId, SyncOptions options)Invoke (byte msgId, NetworkPeer peer, int identityId, byte instanceId, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0) <p>Invokes an RPC using <code>SyncOptions</code> to specify buffer, target, delivery mode, group ID, data cache, and sequence channel, targeting both a <code>NetworkIdentity</code> and script instance.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The ID of the <code>NetworkIdentity</code> to target. <code>instanceId</code> <code>byte</code> The ID of the script instance to target. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example <pre><code>// Example of invoking an RPC with SyncOptions targeting a specific identity and script instance\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    Target = Target.Self,\n    DeliveryMode = DeliveryMode.Unreliable,\n    GroupId = 0,\n    DataCache = DataCache.None,\n    SequenceChannel = 0\n};\nNetworkManager.Server.Invoke(1, clientPeer, identityId: 101, instanceId: 5, syncOptions);\n</code></pre> <p>Invokes an RPC with detailed parameters for buffer, target, delivery mode, grouping, and sequencing, targeting both a <code>NetworkIdentity</code> and script instance.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The ID of the <code>NetworkIdentity</code> to target. <code>instanceId</code> <code>byte</code> The ID of the script instance to target. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>target</code> <code>Target</code> The target for the RPC, such as all clients or a specific peer. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>groupId</code> <code>int</code> ID for grouping related messages (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Specifies how the message data is cached (default is <code>None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example <pre><code>// Example of invoking an RPC targeting a specific identity and script instance with detailed parameters(optional)\nNetworkManager.Server.Invoke(\n    1,\n    clientPeer,\n    identityId: 101,\n    instanceId: 5,\n    buffer: myDataBuffer,\n    target: Target.All,\n    deliveryMode: DeliveryMode.Unreliable,\n    groupId: 0,\n    dataCache: DataCache.None,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Identity and Instance-Specific Invocation: Targets a specific <code>NetworkIdentity</code> using <code>identityId</code> and a specific script instance using <code>instanceId</code>, ensuring precise correspondence with the intended script or object.</li> <li>Flexible Targeting: Supports targeting all clients, server-only, or specific peers, providing control over who receives the RPC.</li> <li>Reliability Options: Provides reliable, ordered delivery or lightweight, unordered options depending on the use case.</li> <li>Sequencing and Grouping: Allows message organization with group IDs and sequence channels, ensuring consistency across channels.</li> <li>Usage: Ideal for invoking RPCs on specific entities and script instances, particularly for commands or updates that are relevant to targeted objects or specific components.</li> </ul> <p>Note</p> <p>This function is also available on the <code>client side</code>, but does not load the <code>peer</code> parameter.</p>"},{"location":"api_reference/#invokeserver","title":"Invoke(Server)","text":"<p>Invokes a Remote Procedure Call (RPC) on clients, targeting a specific network identity by its unique ID, with options for target, delivery mode, grouping, and sequencing.</p> <ul> <li>Signature:</li> <li><code>public static void Invoke(byte msgId, NetworkPeer peer, int identityId, SyncOptions options)</code></li> <li><code>public static void Invoke(byte msgId, NetworkPeer peer, int identityId, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>Invoke</code> method allows the server to execute a specific RPC on clients by using the unique <code>identityId</code> of a network identity. Unlike global RPCs, this method requires the identity ID to establish correspondence, ensuring that only scripts or objects tied to that identity will respond. This method offers flexibility for customizing message delivery with options such as buffer, target recipients, delivery reliability, grouping, and message sequencing.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The unique ID of the <code>NetworkIdentity</code> that will receive the RPC. <code>options</code> <code>SyncOptions</code> A set of options for synchronization (used in the first overload). <code>buffer</code> <code>DataBuffer</code> Optional data buffer to send. <code>target</code> <code>Target</code> Specifies the target for the RPC, such as all clients or a specific peer (default is <code>All</code>). <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code> (default), <code>Unreliable</code>, etc. <code>groupId</code> <code>int</code> ID for grouping related messages together (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Cache option for the data being sent (default is <code>DataCache.None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing to manage order consistency across channels (default is <code>0</code>). <p>Overloads</p> Invoke (byte msgId, NetworkPeer peer, int identityId, SyncOptions options)Invoke (byte msgId, NetworkPeer peer, int identityId, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0) <p>Invokes an RPC using a <code>SyncOptions</code> instance to specify buffer, target, delivery mode, group ID, data cache, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The ID of the <code>NetworkIdentity</code> to target. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example <pre><code>// Example of invoking an RPC with SyncOptions targeting a specific identity\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    Target = Target.Self,\n    DeliveryMode = DeliveryMode.Unreliable,\n    GroupId = 0,\n    DataCache = DataCache.None,\n    SequenceChannel = 0\n};\nNetworkManager.Server.Invoke(1, clientPeer, identityId: 101, syncOptions);\n</code></pre> <p>Invokes an RPC with detailed parameters for buffer, target, delivery mode, grouping, and sequencing.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The ID of the <code>NetworkIdentity</code> to target. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>target</code> <code>Target</code> The target for the RPC, such as all clients or a specific peer. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>groupId</code> <code>int</code> ID for grouping related messages (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Specifies how the message data is cached (default is <code>None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example <pre><code>// Example of invoking an RPC targeting a specific identity with detailed parameters(optional)\nNetworkManager.Server.Invoke(\n    1,\n    clientPeer,\n    identityId: 101,\n    buffer: myDataBuffer,\n    target: Target.All,\n    deliveryMode: DeliveryMode.Unreliable,\n    groupId: 0,\n    dataCache: DataCache.None,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Identity-Specific Invocation: Targets a specific <code>NetworkIdentity</code> using <code>identityId</code>, ensuring the RPC is directed only to matching identities.</li> <li>Flexible Targeting: Supports targeting all clients, server-only, or specific peers, allowing control over who receives the RPC.</li> <li>Reliability Options: Provides reliable, ordered delivery or lightweight, unordered options depending on the use case.</li> <li>Sequencing and Grouping: Allows message organization with group IDs and sequence channels, ensuring consistency across channels.</li> <li>Usage: Ideal for invoking RPCs on specific entities across clients, especially for commands that are only relevant to targeted objects or scripts.</li> </ul> <p>Note</p> <p>This function is also available on the <code>client side</code>, but does not load the <code>peer</code> parameter.</p>"},{"location":"api_reference/#globalinvokeserver","title":"GlobalInvoke(Server)","text":"<p>Invokes a global Remote Procedure Call (RPC) on clients, independent of script instance or identity, using customizable options for target, delivery mode, grouping, and sequencing.</p> <ul> <li>Signature:</li> <li><code>public static void GlobalInvoke(byte msgId, NetworkPeer peer, SyncOptions options)</code></li> <li><code>public static void GlobalInvoke(byte msgId, NetworkPeer peer, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>GlobalInvoke</code> method allows the server to invoke a global RPC on connected clients. Unlike instance-based RPCs, <code>GlobalInvoke</code> does not require a specific script instance or identity, allowing any client-side script with the matching RPC to be called directly. This is ideal for general-purpose commands and broadcasts. The method offers flexible parameters for controlling the target recipients, delivery reliability, grouping, and message sequencing.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>options</code> <code>SyncOptions</code> A set of options for synchronization (used in the first overload). <code>buffer</code> <code>DataBuffer</code> Optional data buffer to send. <code>target</code> <code>Target</code> Specifies the target for the RPC, such as all clients or a specific peer (default is <code>All</code>). <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code> (default), <code>Unreliable</code>, etc. <code>groupId</code> <code>int</code> ID for grouping related messages together (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Cache option for the data being sent (default is <code>DataCache.None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing to manage order consistency across channels (default is <code>0</code>). <p>Overloads</p> GlobalInvoke (byte msgId, NetworkPeer peer, SyncOptions options)GlobalInvoke (byte msgId, NetworkPeer peer, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0) <p>Invokes an RPC on clients using a <code>SyncOptions</code> instance to specify buffer, target, delivery mode, group ID, data cache, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer to whom the RPC is invoked. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example <pre><code>// Example of invoking a global RPC with SyncOptions\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    Target = Target.All,\n    DeliveryMode = DeliveryMode.Reliable,\n    GroupId = 0,\n    DataCache = DataCache.None,\n    SequenceChannel = 0\n};\nNetworkManager.Server.GlobalInvoke(1, clientPeer, syncOptions);\n</code></pre> <p>Invokes an RPC on clients with detailed parameters for buffer, target, delivery mode, grouping, and sequencing.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer to whom the RPC is invoked. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>target</code> <code>Target</code> The target for the RPC, such as all clients or a specific peer. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>groupId</code> <code>int</code> ID for grouping related messages (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Specifies how the message data is cached (default is <code>None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example <pre><code>// Example of invoking a global RPC with detailed parameters(optional)\nNetworkManager.Server.GlobalInvoke(\n    1,\n    clientPeer,\n    buffer: myDataBuffer,\n    target: Target.Self,\n    deliveryMode: DeliveryMode.Reliable,\n    groupId: 0,\n    dataCache: DataCache.None,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Global Invocation: Unlike instance-specific RPCs, <code>GlobalInvoke</code> targets clients globally, without needing script identity or instance details.</li> <li>Flexible Targeting: Supports targeting all clients, server-only, or specific peers, allowing flexible control over who receives the RPC.</li> <li>Reliability Options: Provides reliable, ordered delivery or lightweight, unordered options depending on the use case.</li> <li>Sequencing and Grouping: Allows message organization with group IDs and sequence channels, ensuring consistency across channels.</li> <li>Usage: Ideal for broadcasting general-purpose commands or notifications across clients without binding to specific instances.</li> </ul> <p>Note</p> <p>This function is also available on the <code>client side</code>, but does not load the <code>peer</code> parameter.</p>"},{"location":"api_reference/#trygetidentity","title":"TryGetIdentity","text":"<p>Attempts to retrieve a <code>NetworkIdentity</code> instance by its unique identity ID.</p> <ul> <li>Signature: <code>public static bool TryGetIdentity(int identityId, out NetworkIdentity identity)</code></li> </ul> <p>Description</p> <p>The <code>TryGetIdentity</code> method searches for a <code>NetworkIdentity</code> in the networked identities collection using a unique <code>identityId</code>. If the <code>NetworkIdentity</code> is found, it is returned via the <code>out</code> parameter; otherwise, <code>null</code> is returned. This method provides a safe and efficient way to check if an identity exists before attempting to interact with it.</p> <p>Parameters</p> Parameter Type Description <code>identityId</code> <code>int</code> The unique ID of the <code>NetworkIdentity</code> to retrieve. <code>identity</code> <code>NetworkIdentity</code> The retrieved <code>NetworkIdentity</code> instance, or <code>null</code> if not found. <p>Returns</p> <ul> <li><code>bool</code>: Returns <code>true</code> if the <code>NetworkIdentity</code> was found; otherwise, <code>false</code>.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving a NetworkIdentity by its unique ID on the server\nint identityId = 101;\nif (NetworkManager.Server.TryGetIdentity(identityId, out NetworkIdentity networkIdentity))\n{\n    Debug.Log($\"NetworkIdentity with ID {identityId} found: {networkIdentity.name}\");\n}\nelse\n{\n    Debug.Log($\"NetworkIdentity with ID {identityId} not found.\");\n}\n\n// Example of retrieving a NetworkIdentity by its unique ID on the client\nif (NetworkManager.Client.TryGetIdentity(identityId, out NetworkIdentity networkIdentity))\n{\n    Debug.Log($\"NetworkIdentity with ID {identityId} found: {networkIdentity.name}\");\n}\nelse\n{\n    Debug.Log($\"NetworkIdentity with ID {identityId} not found.\");\n}\n</code></pre>"},{"location":"api_reference/#addprefab","title":"AddPrefab","text":"<p>Adds a prefab to the NetworkManager's registration list if it hasn\u2019t been registered already.</p> <ul> <li>Signature: <code>public static void AddPrefab(NetworkIdentity prefab)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to add to the registration list. <p>Description</p> <p>Registers a <code>NetworkIdentity</code> prefab for network spawning. This method checks if a prefab with the same name already exists in the list, and if so, it will not add it again. This ensures that each prefab is unique in the registration list.</p> <p>Example</p> <pre><code>   // Example of adding a prefab to the registration list\n   NetworkManager.AddPrefab(myPrefabIdentity);\n</code></pre>"},{"location":"api_reference/#getprefab","title":"GetPrefab","text":"<p>Retrieves a prefab from the NetworkManager's registered list by either its name or index.</p> <ul> <li>Signature: </li> <li><code>public static NetworkIdentity GetPrefab(string prefabName)</code></li> <li><code>public static NetworkIdentity GetPrefab(int index)</code></li> </ul> GetPrefab (string prefabName)GetPrefab (int index) <p>Retrieves a prefab by its name.</p> Parameter Type Description <code>prefabName</code> <code>string</code> The name of the prefab to retrieve. <ul> <li>Returns: <code>NetworkIdentity</code> \u2014 The prefab with the specified name.</li> <li>Exceptions: Throws an <code>Exception</code> if the prefab with the specified name is not found.</li> </ul> Example <pre><code>   // Example of retrieving a prefab by name\n   try\n   {\n       NetworkIdentity playerPrefab = NetworkManager.GetPrefab(\"Player\");\n       Debug.Log(\"Prefab retrieved successfully by name.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre> <p>Retrieves a prefab by its index in the registered list.</p> Parameter Type Description <code>index</code> <code>int</code> The index of the prefab to retrieve in the list. <ul> <li>Returns: <code>NetworkIdentity</code> \u2014 The prefab at the specified index.</li> <li>Exceptions: Throws an <code>IndexOutOfRangeException</code> if the index is out of bounds.</li> </ul> Example <pre><code>   // Example of retrieving a prefab by index\n   try\n   {\n       NetworkIdentity enemyPrefab = NetworkManager.GetPrefab(0);\n       Debug.Log(\"Prefab retrieved successfully by index.\");\n   }\n   catch (IndexOutOfRangeException ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre> <p>Description</p> <p>This method provides two overloads for retrieving a <code>NetworkIdentity</code> prefab from the NetworkManager\u2019s registration list. You can either search by the name of the prefab or by its index within the list. If a matching prefab is found, it is returned; otherwise, an appropriate exception is thrown, ensuring that only registered prefabs are used for network spawning.</p> <p>Remarks</p> <ul> <li>By Name: Throws an <code>Exception</code> if the prefab with the specified name is not found in the registration list.</li> <li>By Index: Throws an <code>IndexOutOfRangeException</code> if the index is out of bounds.</li> <li>Useful for scenarios where dynamic instantiation of networked objects is required, either by specific name or by predefined order in the list.</li> </ul>"},{"location":"api_reference/#connect","title":"Connect","text":"<p>Establishes a connection to a specified server address and port. There are two overloads for this method, allowing you to specify a client listening port if needed.</p> <ul> <li>Signature:</li> <li><code>public static void Connect(string address, int port)</code></li> <li><code>public static void Connect(string address, int port, int listenPort)</code></li> </ul> Connect (string address, int port)Connect (string address, int port, int listenPort) <p>Connects to the server using the specified <code>address</code> and <code>port</code>. The client will use the default listening port defined in <code>Manager.m_ClientListenPort</code>.</p> Parameter Type Description <code>address</code> <code>string</code> The IP address of the server. <code>port</code> <code>int</code> The port number on the server. <ul> <li>Exceptions: Throws an <code>Exception</code> if the client is already active, instructing to stop the client before reconnecting.</li> </ul> Example <pre><code>// Connect to a server with default client listening port\nNetworkManager.Connect(\"192.168.1.1\", 7777);\n</code></pre> <p>Connects to the server using the specified <code>address</code> and <code>port</code>, with the client listening on the specified <code>listenPort</code>.</p> Parameter Type Description <code>address</code> <code>string</code> The IP address of the server. <code>port</code> <code>int</code> The port number on the server. <code>listenPort</code> <code>int</code> The port number on which the client listens. <ul> <li>Exceptions: Throws an <code>Exception</code> if the client is already active, instructing to stop the client before reconnecting.</li> </ul> Example <pre><code>// Connect to a server with a custom client listening port\nNetworkManager.Connect(\"192.168.1.1\", 7777, 8888);\n</code></pre> <p>Description</p> <p>The <code>Connect</code> method initiates a connection to the server at a given IP address and port. If the client is already active, an exception is thrown to prevent multiple connections. In the server build configuration (<code>UNITY_SERVER</code>), client connections are disabled.</p> <p>Remarks</p> <ul> <li>Server Build: In a server build (<code>UNITY_SERVER</code>), client connections are not permitted and will log a message instead.</li> <li>Exception Handling: Ensure to call <code>StopClient()</code> before reconnecting if the client is already active to avoid exceptions.</li> <li>Listening Port: Use the overload with <code>listenPort</code> if a custom listening port is required for the client.</li> </ul>"},{"location":"api_reference/#disconnectpeer","title":"DisconnectPeer","text":"<p>Disconnects a specified peer from the server.</p> <ul> <li>Signature: <code>public static void DisconnectPeer(NetworkPeer peer)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>peer</code> <code>NetworkPeer</code> The network peer to disconnect. <p>Description</p> <p>The <code>DisconnectPeer</code> method removes the specified <code>NetworkPeer</code> from the server if the server is currently active. If the server has not been initialized, an exception is thrown to prompt server startup before disconnection.</p> <p>Example</p> <pre><code>   // Example of disconnecting a peer\n   try\n   {\n       NetworkPeer somePeer = GetPeer(); // Assume this retrieves a valid NetworkPeer\n       NetworkManager.DisconnectPeer(somePeer);\n       Debug.Log(\"Peer disconnected successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#disconnect","title":"Disconnect","text":"<p>Disconnects the local client from the server.</p> <ul> <li>Signature: <code>public static void Disconnect()</code></li> </ul> <p>Description</p> <p>The <code>Disconnect</code> method terminates the connection between the local client and the server, if the client is currently active. If the client has not been initialized, an exception is thrown to prompt a connection attempt before disconnection.</p> <p>Example</p> <pre><code>   // Example of disconnecting the client from the server\n   try\n   {\n       NetworkManager.Disconnect();\n       Debug.Log(\"Client disconnected successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#stopclient","title":"StopClient","text":"<p>Stops the local client and ends its connection to the server.</p> <ul> <li>Signature: <code>public static void StopClient()</code></li> </ul> <p>Description</p> <p>The <code>StopClient</code> method halts the local client\u2019s network operations, fully disconnecting it from the server if it is currently active. If the client has not been initialized, an exception is thrown to prompt a connection attempt before stopping.</p> <p>Example</p> <pre><code>   // Example of stopping the client\n   try\n   {\n       NetworkManager.StopClient();\n       Debug.Log(\"Client stopped successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#fastwrite","title":"FastWrite","text":"<p>Writes one or more primitive values to a <code>DataBuffer</code>, utilizing <code>stackalloc</code> to avoid allocations and ensure high performance. This method is available in multiple overloads, allowing for writing up to six primitive values in a single call.</p> <ul> <li>Signature:</li> <li><code>public static DataBuffer FastWrite&lt;T1&gt;(T1 t1) where T1 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2&gt;(T1 t1, T2 t2) where T1 : unmanaged where T2 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3&gt;(T1 t1, T2 t2, T3 t3) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4&gt;(T1 t1, T2 t2, T3 t3, T4 t4) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4, T5&gt;(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4, T5, T6&gt;(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged where T6 : unmanaged</code></li> </ul> <p>Description</p> <p>Each overload of <code>FastWrite</code> allows for writing up to six unmanaged primitive values to a <code>DataBuffer</code>. By using <code>stackalloc</code>, these methods avoid memory allocations, making them highly efficient for network messaging. The returned <code>DataBuffer</code> must be disposed or used within a <code>using</code> statement to ensure proper memory management.</p> <p>Returns</p> <ul> <li><code>DataBuffer</code>: The network message buffer containing the written values.</li> </ul> FastWrite (T1 t1)FastWrite (T1 t1, T2 t2)FastWrite (T1 t1, T2 t2, T3 t3)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4, T5 t5)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) <p>Writes a single unmanaged value to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes two unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes three unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A'))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes four unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes five unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. <code>t5</code> <code>T5</code> The fifth value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true, 99))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes six unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. <code>t5</code> <code>T5</code> The fifth value to write to the buffer. <code>t6</code> <code>T6</code> The sixth value to write to the buffer. Example <pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true, 99, 2.718))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Remarks</p> <ul> <li>Disposal: The caller must ensure that the returned <code>DataBuffer</code> is disposed or used within a <code>using</code> statement to prevent memory leaks.</li> <li>Performance: By using <code>stackalloc</code>, this method avoids heap allocations, offering high performance for network messaging.</li> <li>Generic Constraints: Only unmanaged types are allowed, ensuring compatibility with <code>DataBuffer</code> for efficient serialization.</li> </ul>"},{"location":"api_reference/#frombinary","title":"FromBinary","text":"<p>Deserializes an object from binary format using <code>MemoryPackSerializer</code>.</p> <ul> <li>Signature: <code>public static T FromBinary&lt;T&gt;(byte[] data, MemoryPackSerializerOptions settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to deserialize. <p>Parameters</p> Parameter Type Description <code>data</code> <code>byte[]</code> The byte array containing the binary data to deserialize. <code>settings</code> <code>MemoryPackSerializerOptions</code> Optional settings for deserialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>FromBinary</code> method deserializes an object of type <code>T</code> from a binary byte array using the <code>MemoryPackSerializer</code>. It allows specifying optional deserialization settings through <code>MemoryPackSerializerOptions</code>. If no settings are provided, the method uses the default settings defined in <code>BufferWriterExtensions.DefaultMemoryPackSettings</code>.</p> <p>Returns</p> <ul> <li><code>T</code>: The deserialized object of type <code>T</code>.</li> </ul> <p>Example</p> <pre><code>// Example of deserializing an object from binary data\nbyte[] binaryData = GetBinaryData(); // Assume this retrieves a valid byte array\nMyObject deserializedObject = NetworkManager.FromBinary&lt;MyObject&gt;(binaryData);\n</code></pre>"},{"location":"api_reference/#tobinary","title":"ToBinary","text":"<p>Converts an object to binary format using <code>MemoryPackSerializer</code>.</p> <ul> <li>Signature: <code>public static byte[] ToBinary&lt;T&gt;(T obj, MemoryPackSerializerOptions settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to serialize. <p>Parameters</p> Parameter Type Description <code>obj</code> <code>T</code> The object to be converted to binary format. <code>settings</code> <code>MemoryPackSerializerOptions</code> Optional settings for serialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>ToBinary</code> method serializes an object of type <code>T</code> into a binary byte array using <code>MemoryPackSerializer</code>. It allows specifying optional serialization settings via <code>MemoryPackSerializerOptions</code>. If no settings are provided, the method uses the default settings from <code>BufferWriterExtensions.DefaultMemoryPackSettings</code>.</p> <p>Returns</p> <ul> <li><code>byte[]</code>: A byte array representing the binary serialization of the object.</li> </ul> <p>Example</p> <pre><code>// Example of serializing an object to binary data\nMyObject obj = new MyObject();\nbyte[] binaryData = NetworkManager.ToBinary(obj);\n\n// Example with custom settings\nMemoryPackSerializerOptions customSettings = new MemoryPackSerializerOptions\n{\n    // Custom settings configuration\n};\nbyte[] binaryData = NetworkManager.ToBinary(obj, customSettings);\n</code></pre>"},{"location":"api_reference/#fromjson","title":"FromJson","text":"<p>Deserializes an object from JSON format.</p> <ul> <li>Signature: <code>public static T FromJson&lt;T&gt;(string json, JsonSerializerSettings settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to deserialize. <p>Parameters</p> Parameter Type Description <code>json</code> <code>string</code> The JSON string to deserialize. <code>settings</code> <code>JsonSerializerSettings</code> Optional settings for JSON deserialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>FromJson</code> method deserializes an object of type <code>T</code> from a JSON string. This method allows specifying optional deserialization settings via <code>JsonSerializerSettings</code>. If no settings are provided, the default settings from <code>BufferWriterExtensions.DefaultJsonSettings</code> are used.</p> <p>Returns</p> <ul> <li><code>T</code>: The deserialized object of type <code>T</code>.</li> </ul> <p>Example</p> <pre><code>// Example of deserializing an object from a JSON string\nstring jsonString = \"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":30}\";\nPerson person = NetworkManager.FromJson&lt;Person&gt;(jsonString);\n\n// Example with custom settings\nJsonSerializerSettings customSettings = new JsonSerializerSettings\n{\n    Formatting = Formatting.Indented\n};\nPerson person = NetworkManager.FromJson&lt;Person&gt;(jsonString, customSettings);\n</code></pre>"},{"location":"api_reference/#tojson","title":"ToJson","text":"<p>Converts an object to JSON format.</p> <ul> <li>Signature: <code>public static string ToJson&lt;T&gt;(T obj, JsonSerializerSettings settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to serialize. <p>Parameters</p> Parameter Type Description <code>obj</code> <code>T</code> The object to be converted to JSON format. <code>settings</code> <code>JsonSerializerSettings</code> Optional settings for JSON serialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>ToJson</code> method serializes an object of type <code>T</code> into a JSON string using <code>JsonConvert</code>. This method allows for optional JSON serialization settings via <code>JsonSerializerSettings</code>. If no settings are specified, it uses the default settings defined in <code>BufferWriterExtensions.DefaultJsonSettings</code>.</p> <p>Returns</p> <ul> <li><code>string</code>: A JSON string representation of the serialized object.</li> </ul> <p>Example</p> <pre><code>// Example of serializing an object to JSON format\nPerson person = new Person { Name = \"John\", Age = 30 };\nstring jsonString = NetworkManager.ToJson(person);\n\n// Example with custom settings\nJsonSerializerSettings customSettings = new JsonSerializerSettings\n{\n    Formatting = Formatting.Indented\n};\nstring jsonString = NetworkManager.ToJson(person, customSettings);\n</code></pre>"},{"location":"api_reference/#initializemodule","title":"InitializeModule","text":"<p>Initializes a specified network module based on the provided <code>Module</code> type.</p> <ul> <li>Signature: <code>public static void InitializeModule(Module module)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>module</code> <code>Module</code> The type of module to initialize. <p>Description</p> <p>The <code>InitializeModule</code> method initializes a network module based on the specified <code>Module</code> type. This includes setting up components for ticking, network time, console, connections, and matchmaking as required. The method ensures that the initialization occurs on the main thread and applies appropriate configurations based on each module\u2019s unique requirements.</p> <p>Module Types</p> <ul> <li><code>TickSystem</code>: Initializes a network tick system if one doesn\u2019t already exist. Sets up the tick rate using <code>Manager.m_TickRate</code>.</li> <li><code>NtpClock</code>: Initializes an SNTP clock based on <code>NetworkClock</code> settings, configuring interval and tick timing.</li> <li><code>Console</code>: Initializes a <code>NetworkConsole</code> instance.</li> <li><code>Connection</code>: Sets up the client and server transporters, checks for a transporter component, and configures network connection. Includes logic for auto-starting the server and client based on specific address conditions and the current build configuration.</li> <li><code>Matchmaking</code>: Initializes the network matchmaking module.</li> </ul> <p>Example</p> <pre><code>// Example of initializing the TickSystem module\nNetworkManager.InitializeModule(Module.TickSystem);\n\n// Example of initializing the Connection module\ntry\n{\n    NetworkManager.InitializeModule(Module.Connection);\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre> <p>Remarks</p> <ul> <li>Thread Safety: The method enforces that initialization occurs on the main thread to prevent multithreading issues.</li> <li>Connection Transporter: Throws an Exception if no transporter is found on NetworkManager when initializing the Connection module.</li> <li>Auto-Start Logic: In the Connection module, auto-start behavior is configured based on the client\u2019s address. The server will only auto-start if the address is recognized as localhost or a public IP address.</li> <li>Build Configuration: Auto-starting behavior may vary based on build configuration. For instance, in OMNI_RELEASE builds, both server and client auto-start are enabled by default.</li> </ul>"},{"location":"api_reference/#loadscene-loadsceneasync","title":"LoadScene / LoadSceneAsync","text":"<p>Loads a scene by name or index, with options for synchronous or asynchronous loading. These methods also provide optional parameters to destroy the current scene before loading a new one.</p> <ul> <li>Signature:</li> <li><code>public static void LoadScene(string sceneName, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static AsyncOperation LoadSceneAsync(string sceneName, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static void LoadScene(int index, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static AsyncOperation LoadSceneAsync(int index, LoadSceneMode mode = LoadSceneMode.Single)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Specifies whether to load the scene in <code>Single</code> or <code>Additive</code> mode (default is <code>Single</code>). <p>Description</p> <p>Each overload of <code>LoadScene</code> and <code>LoadSceneAsync</code> allows loading scenes either by name or by build index, with the option to specify loading in single or additive mode. The methods also include a call to <code>DestroyScene</code> to clear the current scene before loading the new one, supporting smooth transitions and memory management.</p> <p>Overloads</p> LoadScene (string sceneName, LoadSceneMode mode = LoadSceneMode.Single)LoadSceneAsync (string sceneName, LoadSceneMode mode = LoadSceneMode.Single)LoadScene (int index, LoadSceneMode mode = LoadSceneMode.Single)LoadSceneAsync (int index, LoadSceneMode mode = LoadSceneMode.Single) <p>Loads a scene by its name in synchronous mode.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example <pre><code>// Load a scene by name\nNetworkManager.LoadScene(\"MainScene\");\n</code></pre> <p>Loads a scene by its name in asynchronous mode, returning an <code>AsyncOperation</code>.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example <pre><code>// Load a scene asynchronously by name\nAsyncOperation loadOperation = NetworkManager.LoadSceneAsync(\"MainScene\");\n</code></pre> <p>Loads a scene by its build index in synchronous mode.</p> Parameter Type Description <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example <pre><code>// Load a scene by build index\nNetworkManager.LoadScene(1);\n</code></pre> <p>Loads a scene by its build index in asynchronous mode, returning an <code>AsyncOperation</code>.</p> Parameter Type Description <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example <pre><code>// Load a scene asynchronously by build index\nAsyncOperation loadOperation = NetworkManager.LoadSceneAsync(1);\n</code></pre> <p>Remarks</p> <ul> <li>DestroyScene: Each method calls <code>DestroyScene</code> before loading to remove the current scene and free resources.</li> <li>LoadSceneMode: Allows loading in <code>Single</code> mode, which replaces the current scene, or <code>Additive</code> mode, which loads the new scene on top of the existing one.</li> <li>AsyncOperation: In asynchronous methods, an <code>AsyncOperation</code> is returned, which can be used to track the progress of scene loading.</li> <li>Error Handling: Ensure the specified scene name or index is valid to avoid loading errors.</li> </ul>"},{"location":"api_reference/#unloadsceneasync","title":"UnloadSceneAsync","text":"<p>Asynchronously unloads a scene by its name or index with options for unloading behavior.</p> <ul> <li>Signature:</li> <li><code>public static AsyncOperation UnloadSceneAsync(string sceneName, UnloadSceneOptions options = UnloadSceneOptions.None)</code></li> <li><code>public static AsyncOperation UnloadSceneAsync(int index, bool useBuildIndex = false, UnloadSceneOptions options = UnloadSceneOptions.None)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to unload. <code>index</code> <code>int</code> The index of the scene to unload, which can refer to the build index or scene load order. <code>useBuildIndex</code> <code>bool</code> Indicates if the <code>index</code> parameter should be interpreted as the build index (default is <code>false</code>). <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). <p>Description</p> <p>The <code>UnloadSceneAsync</code> method provides asynchronous scene unloading capabilities. You can specify the scene to unload either by its name or index, with the option to interpret the index as the build index. Each method first calls <code>DestroyScene</code> to handle any necessary scene cleanup before initiating the asynchronous unloading operation using <code>SceneManager.UnloadSceneAsync</code>.</p> <p>Overloads</p> UnloadSceneAsync (string sceneName, UnloadSceneOptions options = UnloadSceneOptions.None)UnloadSceneAsync (int index, bool useBuildIndex = false, UnloadSceneOptions options = UnloadSceneOptions.None) <p>Unloads a scene asynchronously by its name.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to unload. <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). Example <pre><code>// Unload a scene asynchronously by name\nAsyncOperation unloadOperation = NetworkManager.UnloadSceneAsync(\"MainScene\");\n</code></pre> <p>Unloads a scene asynchronously by its index, with the option to interpret the index as the build index.</p> Parameter Type Description <code>index</code> <code>int</code> The index of the scene to unload. <code>useBuildIndex</code> <code>bool</code> Whether the index refers to the build index (default is <code>false</code>). <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). Example <pre><code>// Unload a scene asynchronously by build index\nAsyncOperation unloadOperation = NetworkManager.UnloadSceneAsync(1, useBuildIndex: true);\n</code></pre> <p>Remarks</p> <ul> <li>DestroyScene: Each method calls <code>DestroyScene</code> before unloading to handle any necessary cleanup operations and prevent memory leaks.</li> <li>UnloadSceneOptions: Options can be provided for customizing the unloading process, such as removing dependencies.</li> <li>AsyncOperation: Returns an <code>AsyncOperation</code> that can be used to track the progress of the unloading process.</li> <li>Usage: Ideal for offloading scenes when they are no longer needed, helping to manage memory and resources efficiently.</li> </ul>"},{"location":"api_reference/#spawnonclient","title":"SpawnOnClient","text":"<p>Instantiates a network identity on the client.</p> <ul> <li>Signature: <code>public static NetworkIdentity SpawnOnClient(NetworkIdentity prefab, int peerId, int identityId)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peerId</code> <code>int</code> The ID of the peer who owns the instantiated object. <code>identityId</code> <code>int</code> The ID of the instantiated object. <p>Description</p> <p>The <code>SpawnOnClient</code> method instantiates a <code>NetworkIdentity</code> object on the client. It checks if the instantiated object is owned by the local player and updates the <code>LocalPlayer</code> reference if appropriate. After instantiation, it notifies the server that this identity has been spawned on the client side.</p> <p>Returns</p> <ul> <li><code>NetworkIdentity</code>: The instantiated network identity object.</li> </ul> <p>Example</p> <pre><code>// Example of spawning a network identity on the client\nNetworkIdentity playerPrefab = GetPlayerPrefab(); // Assume this retrieves a valid NetworkIdentity prefab\nNetworkIdentity newPlayer = NetworkManager.SpawnOnClient(playerPrefab, peerId: 1, identityId: 1001);\nDebug.Log(\"Player instantiated on client: \" + newPlayer.name);\n</code></pre>"},{"location":"api_reference/#spawnonserver","title":"SpawnOnServer","text":"<p>Instantiates a network identity on the server for a specific peer or with a specified ID.</p> <ul> <li>Signature:</li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, NetworkPeer peer)</code></li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, NetworkPeer peer, int identityId)</code></li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, int peerId, int identityId = 0)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the instantiated object. <code>peerId</code> <code>int</code> The ID of the peer who will receive the instantiated object (for overloads without <code>peer</code>). <code>identityId</code> <code>int</code> The ID of the instantiated object. If not provided, a unique ID will be dynamically generated. <p>Description</p> <p>The <code>SpawnOnServer</code> method provides multiple overloads to instantiate a <code>NetworkIdentity</code> object on the server. The instantiation can be performed for a specific peer, identified either by a <code>NetworkPeer</code> object or a <code>peerId</code>. If an <code>identityId</code> is not provided, a unique ID is generated dynamically.</p> <p>Overloads</p> SpawnOnServer (NetworkIdentity prefab, NetworkPeer peer)SpawnOnServer (NetworkIdentity prefab, NetworkPeer peer, int identityId)SpawnOnServer (NetworkIdentity prefab, int peerId, int identityId = 0) <p>Instantiates a network identity on the server for a specific peer.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the object. Example <pre><code>// Example of spawning a network identity on the server for a specific peer\nNetworkIdentity playerPrefab = GetPlayerPrefab();\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, somePeer);\n</code></pre> <p>Instantiates a network identity on the server for a specific peer with a specified identity ID.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the object. <code>identityId</code> <code>int</code> The ID of the instantiated object. Example <pre><code>// Example of spawning a network identity with a specific ID on the server for a peer\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, somePeer, 1001);\n</code></pre> <p>Instantiates a network identity on the server using a peer ID and an optional identity ID. If <code>identityId</code> is not provided, a unique ID is generated dynamically.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peerId</code> <code>int</code> The ID of the peer who will receive the object. <code>identityId</code> <code>int</code> The ID of the instantiated object, or <code>0</code> for a unique ID. Example <pre><code>// Example of spawning a network identity on the server by peer ID, with auto-generated ID\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, peerId: 1);\n</code></pre> <p>Remarks</p> <ul> <li>Dynamic ID Generation: If <code>identityId</code> is <code>0</code>, the method generates a unique ID for the instantiated object using <code>NetworkHelper.GenerateDynamicUniqueId()</code>.</li> <li>Peer Association: The instantiated object is associated with the specified peer, allowing for ownership and network synchronization based on peer ID.</li> <li>Usage: Suitable for spawning networked objects on the server side, with flexibility for assigning specific identity IDs or generating them dynamically.</li> </ul>"},{"location":"api_reference/#sendmessageclient","title":"SendMessage(Client)","text":"<p>Sends a message from the client to the server, with options for specifying message content, delivery mode, and sequence channel.</p> <ul> <li>Signature:</li> <li><code>public static void SendMessage(byte msgId, SyncOptions options)</code></li> <li><code>public static void SendMessage(byte msgId, DataBuffer buffer = null, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>SendMessage</code> method allows the client to send a message to the server, either by using <code>SyncOptions</code> or by specifying detailed parameters such as <code>DataBuffer</code>, <code>DeliveryMode</code>, and <code>SequenceChannel</code>. This function provides flexible control over how messages are delivered, including options for reliable, ordered delivery and custom sequencing to maintain message order.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization, including buffer, delivery mode, and channel. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>deliveryMode</code> <code>DeliveryMode</code> Specifies the delivery mode, such as <code>ReliableOrdered</code> or <code>Unreliable</code> (default is <code>ReliableOrdered</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing, to control message order consistency across channels (default is <code>0</code>). <p>Overloads</p> SendMessage (byte msgId, SyncOptions options)SendMessage (byte msgId, DataBuffer buffer = null, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, byte sequenceChannel = 0) <p>Sends a message to the server using <code>SyncOptions</code> to define the buffer, delivery mode, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example <pre><code>// Example of sending a message using SyncOptions\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    DeliveryMode = DeliveryMode.Unreliable,\n    SequenceChannel = 0\n};\nNetworkManager.Client.SendMessage(1, syncOptions);\n</code></pre> <p>Sends a message to the server with detailed parameters for buffer, delivery mode, and sequencing.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example <pre><code>// Example of sending a message with detailed parameters\nNetworkManager.Client.SendMessage(\n    1,\n    buffer: myDataBuffer,\n    deliveryMode: DeliveryMode.Unreliable,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Client-to-Server Communication: Allows the client to send messages to the server, ideal for client-initiated requests or updates.</li> <li>Flexible Delivery Options: Supports both reliable and unreliable delivery modes, as well as ordered or unordered options, depending on the use case.</li> <li>Sequencing Control: Use the <code>sequenceChannel</code> to maintain message order across multiple channels, ensuring consistency in message flow.</li> <li>Usage: Commonly used for sending custom data, requests, or status updates from the client to the server.</li> </ul>"},{"location":"api_reference/#sendmessageserver","title":"SendMessage(Server)","text":"<p>Sends a message from the server to a client or from a client to other networked peers on the server side, with optional configurable options for target, delivery mode, grouping, and sequencing.</p> <ul> <li>Signature:</li> <li><code>public static void SendMessage(byte msgId, NetworkPeer peer, SyncOptions options)</code></li> <li><code>public static void SendMessage(byte msgId, NetworkPeer peer, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>SendMessage</code> method provides multiple overloads to send a message through the network with flexible settings for various parameters. The method allows specifying the message ID, target peer, and delivery options like delivery mode, group ID, and sequence channel. This enables fine-grained control over how messages are delivered, such as targeting specific peers, ensuring message ordering, and managing data cache. <code>SendMessage</code> is typically used to send data from the server to clients or between clients.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>peer</code> <code>NetworkPeer</code> The peer to send the message to. <code>options</code> <code>SyncOptions</code> A set of options for message synchronization (used in the first overload). <code>buffer</code> <code>DataBuffer</code> Optional data buffer to send. <code>target</code> <code>Target</code> Specifies the target for the message (default is <code>All</code>). <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code> (default), <code>Unreliable</code>, etc. <code>groupId</code> <code>int</code> ID for grouping related messages together (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Cache option for the data being sent (default is <code>DataCache.None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing to manage order consistency across channels (default is <code>0</code>). <p>Overloads</p> SendMessage (byte msgId, NetworkPeer peer, SyncOptions options)SendMessage (byte msgId, NetworkPeer peer, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0) <p>Sends a message using a <code>SyncOptions</code> instance to specify buffer, target, delivery mode, group ID, data cache, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>peer</code> <code>NetworkPeer</code> The peer to send the message to. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example <pre><code>// Example of sending a message with SyncOptions(optional)\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    Target = Target.All,\n    DeliveryMode = DeliveryMode.Unreliable,\n    GroupId = 0,\n    DataCache = DataCache.None,\n    SequenceChannel = 0\n};\nNetworkManager.Server.SendMessage(1, clientPeer, syncOptions);\n</code></pre> <p>Sends a message with detailed parameters for target, delivery mode, grouping, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>peer</code> <code>NetworkPeer</code> The peer to send the message to. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>target</code> <code>Target</code> The target for the message, such as <code>All</code>. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>groupId</code> <code>int</code> ID for grouping related messages (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Specifies how the message data is cached (default is <code>None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example <pre><code>// Example of sending a message with detailed parameters(optional)\nNetworkManager.Server.SendMessage(\n    1,\n    clientPeer,\n    buffer: myDataBuffer,\n    target: Target.All,\n    deliveryMode: DeliveryMode.Unreliable,\n    groupId: 0,\n    dataCache: DataCache.None,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Targeting: Allows flexible message targeting, such as sending to all peers, server-only, or specific groups.</li> <li>Delivery Mode: Supports reliable and ordered delivery, or unreliable options for lightweight</li> </ul>"},{"location":"api_reference/#properties","title":"Properties","text":""},{"location":"api_reference/#receivedbandwidth","title":"ReceivedBandwidth","text":"<p>Gets the <code>BandwidthMonitor</code> for monitoring the server's or client incoming bandwidth.</p> <ul> <li>Signature: <code>public static BandwidthMonitor ReceivedBandwidth =&gt; Connection.Server.ReceivedBandwidth</code></li> </ul> <p>Description</p> <p>The <code>ReceivedBandwidth</code> property provides access to the <code>BandwidthMonitor</code> instance that tracks the server\u2019s or client incoming bandwidth usage. This monitor measures the rate of data being received by the server from clients and vice versa, allowing developers to analyze and optimize network performance.</p> <p>Returns</p> <ul> <li><code>BandwidthMonitor</code>: An instance that tracks and measures the server's or client incoming bandwidth usage.</li> </ul> <p>Example</p> <pre><code>// Example of monitoring changes in the server's average received bandwidth\nNetworkManager.Server.ReceivedBandwidth.OnAverageChanged += (avg) =&gt;\n{\n    Debug.Log($\"Average received bandwidth: {avg} bytes per second\");\n};\n\n// Client side\nNetworkManager.Client.ReceivedBandwidth.OnAverageChanged += (avg) =&gt;\n{\n    Debug.Log($\"Average received bandwidth: {avg} bytes per second\");\n};\n</code></pre>"},{"location":"api_reference/#sentbandwidth","title":"SentBandwidth","text":"<p>Gets the <code>BandwidthMonitor</code> for monitoring the server's or client outgoing bandwidth.</p> <ul> <li>Signature: <code>public static BandwidthMonitor SentBandwidth =&gt; Connection.Server.SentBandwidth</code></li> </ul> <p>Description</p> <p>The <code>SentBandwidth</code> property provides access to the <code>BandwidthMonitor</code> instance that tracks the server\u2019s or client outgoing bandwidth usage. This monitor measures the rate of data being sent from the server to clients and vice versa, allowing developers to observe and manage network performance.</p> <p>Returns</p> <ul> <li><code>BandwidthMonitor</code>: An instance that tracks and measures the server's or client outgoing bandwidth usage.</li> </ul> <p>Example</p> <pre><code>// Example of accessing SentBandwidth\nNetworkManager.Server.SentBandwidth.OnAverageChanged += (avg) =&gt;\n{\n    Debug.Log($\"Average sent bandwidth: {avg} bytes per second\");\n};\n\n// Client side\nNetworkManager.Client.SentBandwidth.OnAverageChanged += (avg) =&gt;\n{\n    Debug.Log($\"Average sent bandwidth: {avg} bytes per second\");\n};\n</code></pre>"},{"location":"api_reference/#serverpeer","title":"ServerPeer","text":"<p>Gets the server peer, which represents the server within the network as a special <code>NetworkPeer</code> instance.</p> <ul> <li>Signature: <code>public static NetworkPeer ServerPeer { get; }</code></li> </ul> <p>Description</p> <p>The <code>ServerPeer</code> property provides a <code>NetworkPeer</code> instance specifically designated to represent the server. This instance can be used to identify the server in network operations, facilitating communication, control, and synchronization between the server and clients.</p> <p>Remarks</p> <ul> <li>Server Representation: <code>ServerPeer</code> acts as a unique identifier for the server in the network, making it distinct from other peers.</li> <li>Usage: Useful for operations where the server needs to be addressed specifically, such as broadcasting messages to all clients or handling server-specific logic.</li> <li>Initialization: The <code>ServerPeer</code> is instantiated with a default IP endpoint (<code>IPAddress.None</code>) and a port of <code>0</code>, signifying that it is used solely for internal identification rather than active communication.</li> </ul> <p>Example</p> <p><pre><code>// Example of using ServerPeer to check if a peer is the server\nif (NetworkManager.Server.ServerPeer.Equals(somePeer))\n{\n    Debug.Log(\"This peer is the server.\");\n}\n\n// Example of using ServerPeer for a server-specific operation\nNetworkPeer serverPeer = NetworkManager.Server.ServerPeer;\nDebug.Log(\"Server peer address: \" + serverPeer.EndPoint);\n</code></pre> Remarks</p> <p>Client-Side: When <code>NetworkManager.Client.ServerPeer</code> is used, it represents the server peer on the client side, exclusively for encryption keys.</p>"},{"location":"api_reference/#peers","title":"Peers","text":"<p>A dictionary that maps peer IDs to <code>NetworkPeer</code> instances, providing access to all connected peers by their unique IDs.</p> <ul> <li>Signature: <code>public static Dictionary&lt;int, NetworkPeer&gt; Peers =&gt; PeersById</code></li> </ul> <p>Description</p> <p>The <code>Peers</code> property provides a dictionary of all active <code>NetworkPeer</code> instances, keyed by their unique integer IDs. This dictionary allows efficient management and retrieval of network peers, making it easy to access specific clients or other networked entities by their ID.</p> <p>Returns</p> <ul> <li><code>Dictionary&lt;int, NetworkPeer&gt;</code>: A dictionary containing all active <code>NetworkPeer</code> instances, indexed by peer IDs.</li> </ul> <p>Example</p> <pre><code>// Example of iterating over all connected peers on the server\nforeach (var kvp in NetworkManager.Server.Peers)\n{\n    int peerId = kvp.Key;\n    NetworkPeer peer = kvp.Value;\n    Debug.Log($\"Peer ID: {peerId}\");\n}\n\n// Example of checking if a specific peer ID exists\nint targetPeerId = 42;\nif (NetworkManager.Server.Peers.ContainsKey(targetPeerId))\n{\n    NetworkPeer peer = NetworkManager.Peers[targetPeerId];\n    Debug.Log($\"Found peer with ID {targetPeerId}\");\n}\nelse\n{\n    Debug.Log($\"No peer found with ID {targetPeerId}\");\n}\n\n// Client side example\nforeach (var kvp in NetworkManager.Client.Peers)\n{\n    int peerId = kvp.Key;\n    NetworkPeer peer = kvp.Value;\n    Debug.Log($\"Peer ID: {peerId}\");\n}\n</code></pre>"},{"location":"api_reference/#identities","title":"Identities","text":"<p>A dictionary that stores all <code>NetworkIdentity</code> instances, mapped by their unique identity IDs.</p> <ul> <li>Signature: <code>public static Dictionary&lt;int, NetworkIdentity&gt; Identities { get; }</code></li> </ul> <p>Description</p> <p>The <code>Identities</code> property provides access to a dictionary containing all <code>NetworkIdentity</code> instances, where each entry is keyed by a unique integer ID (<code>identityId</code>). This dictionary allows efficient retrieval and management of networked identities, enabling easy access to any networked object within the application.</p> <p>Returns</p> <ul> <li><code>Dictionary&lt;int, NetworkIdentity&gt;</code>: A dictionary of <code>NetworkIdentity</code> instances, keyed by unique identity IDs.</li> </ul> <p>Example</p> <pre><code>// Example of iterating over all NetworkIdentity instances on the server\nforeach (var kvp in NetworkManager.Server.Identities)\n{\n    int id = kvp.Key;\n    NetworkIdentity identity = kvp.Value;\n    Debug.Log($\"NetworkIdentity ID: {id}, Name: {identity.name}\");\n}\n\n// Example of checking if a specific ID exists\nint identityId = 101;\nif (NetworkManager.Server.Identities.ContainsKey(identityId))\n{\n    NetworkIdentity identity = NetworkManager.Identities[identityId];\n    Debug.Log($\"Found NetworkIdentity with ID {identityId}: {identity.name}\");\n}\nelse\n{\n    Debug.Log($\"No NetworkIdentity found with ID {identityId}\");\n}\n\n/////////////////////// Client side\n// Example of iterating over all NetworkIdentity instances\nforeach (var kvp in NetworkManager.Client.Identities)\n{\n    int id = kvp.Key;\n    NetworkIdentity identity = kvp.Value;\n    Debug.Log($\"NetworkIdentity ID: {id}, Name: {identity.name}\");\n}\n\n// Example of checking if a specific ID exists\nif (NetworkManager.Client.Identities.ContainsKey(identityId))\n{\n    NetworkIdentity identity = NetworkManager.Identities[identityId];\n    Debug.Log($\"Found NetworkIdentity with ID {identityId}: {identity.name}\");\n}\n</code></pre>"},{"location":"api_reference/#clientlistenport","title":"ClientListenPort","text":"<p>Gets the port on which the client listens for incoming connections.</p> <ul> <li>Signature: <code>public static int ClientListenPort</code></li> </ul> <p>Description</p> <p>The <code>ClientListenPort</code> property provides access to the client\u2019s listening port, as configured in <code>Manager.m_ClientListenPort</code>. This port is used for network communications on the client side, enabling it to receive messages from the server.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number on which the client listens.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the client's listening port\nint clientPort = NetworkManager.ClientListenPort;\nDebug.Log(\"Client listening on port: \" + clientPort);\n</code></pre>"},{"location":"api_reference/#serverlistenport","title":"ServerListenPort","text":"<p>Gets the port on which the server listens for incoming connections.</p> <ul> <li>Signature: <code>public static int ServerListenPort</code></li> </ul> <p>Description</p> <p>The <code>ServerListenPort</code> property provides access to the server\u2019s listening port, as configured in <code>Manager.m_ServerListenPort</code>. This port is used for network communications on the server side, enabling it to accept incoming connections from clients.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number on which the server listens.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the server's listening port\nint serverPort = NetworkManager.ServerListenPort;\nDebug.Log(\"Server listening on port: \" + serverPort);\n</code></pre>"},{"location":"api_reference/#connectport","title":"ConnectPort","text":"<p>Gets the port on which the client connects to the server.</p> <ul> <li>Signature: <code>public static int ConnectPort</code></li> </ul> <p>Description</p> <p>The <code>ConnectPort</code> property provides access to the port number that the client uses to connect to the server, as configured in <code>Manager.m_ConnectPort</code>. This port is the endpoint on the server to which the client establishes a connection.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number that the client uses to connect to the server.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the server's connection port\nint serverConnectionPort = NetworkManager.ConnectPort;\nDebug.Log(\"Client will connect to server on port: \" + serverConnectionPort);\n</code></pre>"},{"location":"api_reference/#connectaddress","title":"ConnectAddress","text":"<p>Gets the IP address or hostname that the client uses to connect to the server.</p> <ul> <li>Signature: <code>public static string ConnectAddress</code></li> </ul> <p>Description</p> <p>The <code>ConnectAddress</code> property provides access to the IP address or hostname of the server that the client connects to, as configured in <code>Manager.m_ConnectAddress</code>. This address is used as the endpoint for the client\u2019s connection to the server.</p> <p>Returns</p> <ul> <li><code>string</code>: The IP address or hostname of the server that the client will connect to.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the server's connection address\nstring serverAddress = NetworkManager.ConnectAddress;\nDebug.Log(\"Client will connect to server at address: \" + serverAddress);\n</code></pre>"},{"location":"api_reference/#framerate","title":"Framerate","text":"<p>Gets the current framerate of the application.</p> <ul> <li>Signature: <code>public static float Framerate { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>Framerate</code> property provides access to the application's current framerate. This value can be used to monitor the performance of the application in real-time, allowing developers to adjust settings or configurations based on performance metrics.</p> <p>Returns</p> <ul> <li><code>float</code>: The current framerate of the application.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the current application framerate\nfloat currentFramerate = NetworkManager.Framerate;\nDebug.Log(\"Current application framerate: \" + currentFramerate + \" FPS\");\n</code></pre>"},{"location":"api_reference/#cputimems","title":"CpuTimeMs","text":"<p>Gets the CPU time in milliseconds per frame.</p> <ul> <li>Signature: <code>public static float CpuTimeMs { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>CpuTimeMs</code> property provides access to the CPU time taken per frame, measured in milliseconds. This metric indicates the amount of time the CPU spends processing each frame, which is useful for monitoring and optimizing application performance.</p> <p>Returns</p> <ul> <li><code>float</code>: The CPU time per frame, in milliseconds.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the CPU time per frame in milliseconds\nfloat cpuTimePerFrame = NetworkManager.CpuTimeMs;\nDebug.Log(\"CPU time per frame: \" + cpuTimePerFrame + \" ms\");\n</code></pre>"},{"location":"api_reference/#clocktime","title":"ClockTime","text":"<p>Gets the current clock time in seconds, based on tick timing or elapsed stopwatch time.</p> <ul> <li>Signature: <code>public static double ClockTime</code></li> </ul> <p>Description</p> <p>The <code>ClockTime</code> property provides the current time in seconds, which is independent of the frame rate. The time source depends on the <code>UseTickTiming</code> setting: - Tick Timing: If <code>UseTickTiming</code> is enabled, the time is based on the <code>TickSystem.ElapsedTicks</code>. - Stopwatch: If <code>UseTickTiming</code> is disabled, the time is derived from <code>_stopwatch.Elapsed.TotalSeconds</code>.</p> <p>This setup allows for precise timing control, whether using fixed ticks or continuous stopwatch measurements.</p> <p>Returns</p> <ul> <li><code>double</code>: The current clock time in seconds.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the current clock time\ndouble currentTime = NetworkManager.ClockTime;\nDebug.Log(\"Current clock time: \" + currentTime + \" seconds\");\n</code></pre>"},{"location":"api_reference/#useticktiming","title":"UseTickTiming","text":"<p>Indicates whether the application is using tick-based timing for the <code>ClockTime</code> property.</p> <ul> <li>Signature: <code>public static bool UseTickTiming { get; private set; } = false</code></li> </ul> <p>Description</p> <p>The <code>UseTickTiming</code> property determines whether the application relies on tick-based timing or real-time stopwatch timing for the <code>ClockTime</code> property. When <code>UseTickTiming</code> is set to <code>true</code>, <code>ClockTime</code> is based on <code>TickSystem.ElapsedTicks</code>; otherwise, it uses <code>_stopwatch.Elapsed.TotalSeconds</code>.</p> <p>Returns</p> <ul> <li><code>bool</code>: <code>true</code> if tick-based timing is enabled; <code>false</code> if stopwatch timing is used.</li> </ul> <p>Example</p> <pre><code>// Example of checking the timing mode\nif (NetworkManager.UseTickTiming)\n{\n    Debug.Log(\"Using tick-based timing for clock time.\");\n}\nelse\n{\n    Debug.Log(\"Using real-time stopwatch timing for clock time.\");\n}\n</code></pre>"},{"location":"api_reference/#localendpoint","title":"LocalEndPoint","text":"<p>Gets the local network endpoint, represented by an <code>IPEndPoint</code> instance.</p> <ul> <li>Signature: <code>public static IPEndPoint LocalEndPoint { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>LocalEndPoint</code> property provides the IP address and port number of the local peer in the form of an <code>IPEndPoint</code> object. This endpoint represents the local network location, allowing other peers to identify and communicate with the local instance.</p> <p>Returns</p> <ul> <li><code>IPEndPoint</code>: The IP address and port of the local peer.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the local network endpoint\nIPEndPoint localEndpoint = NetworkManager.LocalEndPoint;\nDebug.Log(\"Local IP Address: \" + localEndpoint.Address + \", Port: \" + localEndpoint.Port);\n</code></pre>"},{"location":"api_reference/#isclientactive","title":"IsClientActive","text":"<p>Indicates whether the client is currently active, authenticated, and connected.</p> <ul> <li>Signature: <code>public static bool IsClientActive { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>IsClientActive</code> property returns <code>true</code> if the client is currently active, authenticated, and connected to the network; otherwise, it returns <code>false</code>. This property is used to determine the client\u2019s connection status, allowing the application to handle client-specific logic based on whether the client is connected.</p> <p>Returns</p> <ul> <li><code>bool</code>: <code>true</code> if the client is active, authenticated, and connected; <code>false</code> otherwise.</li> </ul> <p>Example</p> <pre><code>// Example of checking if the client is active\nif (NetworkManager.IsClientActive)\n{\n    Debug.Log(\"Client is active and connected to the network.\");\n}\nelse\n{\n    Debug.Log(\"Client is not active.\");\n}\n</code></pre>"},{"location":"api_reference/#isserveractive","title":"IsServerActive","text":"<p>Indicates whether the server is currently active.</p> <ul> <li>Signature: <code>public static bool IsServerActive { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>IsServerActive</code> property returns <code>true</code> if the server is currently active and ready to accept connections; otherwise, it returns <code>false</code>. This property is used to determine the server\u2019s operational status within the network, allowing the application to enable or disable server-dependent features accordingly.</p> <p>Returns</p> <ul> <li><code>bool</code>: <code>true</code> if the server is active; <code>false</code> otherwise.</li> </ul> <p>Example</p> <pre><code>// Example of checking if the server is active\nif (NetworkManager.IsServerActive)\n{\n    Debug.Log(\"Server is active and accepting connections.\");\n}\nelse\n{\n    Debug.Log(\"Server is not active.\");\n}\n</code></pre>"},{"location":"api_reference/#sharedpeer","title":"SharedPeer","text":"<p>Gets the shared peer, which is used to secure communication between peers and the server. This peer is useful for handling encryption and authentication in network communications.</p> <ul> <li>Signature: <code>public static NetworkPeer SharedPeer</code></li> </ul> <p>Description</p> <p>The <code>SharedPeer</code> property provides access to the network peer responsible for securing communication between the client and server. Depending on the network state, it returns the appropriate peer for encryption and authentication:   - Client-Server Mode: When both the client and server are active, it returns <code>Server.ServerPeer</code>.   - Client Only: When only the client is active, it returns <code>Client.ServerPeer</code>.   - Server Only: When only the server is active, it defaults to <code>Server.ServerPeer</code>.</p> <p>This flexibility allows the property to provide the correct peer for communication in different network configurations.</p> <p>Returns</p> <ul> <li><code>NetworkPeer</code>: The peer used for secure communication.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the shared peer for secure communication\nNetworkPeer securePeer = NetworkManager.SharedPeer;\nDebug.Log(\"Shared peer for secure communication: \" + securePeer);\n</code></pre>"},{"location":"api_reference/#localpeer","title":"LocalPeer","text":"<p>Gets the local network peer, representing the client in the network.</p> <ul> <li>Signature: <code>public static NetworkPeer LocalPeer</code></li> </ul> <p>Description</p> <p>The <code>LocalPeer</code> property provides access to an instance of the <code>NetworkPeer</code> class that represents the local peer in the network. This property is used to identify and interact with the local peer in networked operations. If the client is not active or authenticated, attempting to access this property throws an exception, ensuring that only active and verified clients can reference <code>LocalPeer</code>.</p> <p>Returns</p> <ul> <li><code>NetworkPeer</code>: The local peer in the network.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the local network peer\ntry\n{\n    NetworkPeer localPeer = NetworkManager.LocalPeer;\n    Debug.Log(\"Local network peer: \" + localPeer);\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre>"},{"location":"api_reference/#mainthreadid","title":"MainThreadId","text":"<p>Gets the ID of the main thread on which the application is running.</p> <ul> <li>Signature: <code>public static int MainThreadId { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>MainThreadId</code> property provides the thread ID of the main thread, allowing the application to distinguish between the main thread and any background or worker threads. This is useful for ensuring that certain operations, particularly those involving UI updates or Unity API calls, are executed on the main thread.</p> <p>Returns</p> <ul> <li><code>int</code>: The ID of the main thread.</li> </ul> <p>Example</p> <pre><code>// Example of retrieving the main thread ID\nint mainThreadId = NetworkManager.MainThreadId;\nDebug.Log(\"Main thread ID: \" + mainThreadId);\n</code></pre>"},{"location":"api_reference/#pool","title":"Pool","text":"<p>Gets the pool of <code>DataBuffer</code> instances, used to allocate and deallocate <code>DataBuffer</code> objects efficiently.</p> <ul> <li>Signature: <code>public static IObjectPooling&lt;DataBuffer&gt; Pool { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>Pool</code> property provides access to an instance of <code>IObjectPooling&lt;DataBuffer&gt;</code>, which manages the allocation and deallocation of <code>DataBuffer</code> instances. By pooling <code>DataBuffer</code> objects, the application reduces memory allocation overhead and enhances performance, especially in networked applications where buffers are frequently used.</p> <p>Returns</p> <ul> <li><code>IObjectPooling&lt;DataBuffer&gt;</code>: The object pool for managing <code>DataBuffer</code> instances.</li> </ul> <p>Example</p> <pre><code>// Example 1 of using the DataBuffer pool\nDataBuffer buffer = NetworkManager.Pool.Rent();\nNetworkManager.Pool.Return(buffer); // Return the buffer to the pool\n\n// Example 2(Recommended)\nusing DataBuffer buffer = NetworkManager.Pool.Rent(); // Using return the buffer to the pool\n\n// Example 3\nDataBuffer buffer = NetworkManager.Pool.Rent();\nbuffer.Dispose(); // Return the buffer to the pool\n</code></pre>"},{"location":"api_reference/#console","title":"Console","text":"<p>Gets the <code>NetworkConsole</code> instance, which provides access to the network console module for sending and receiving commands.</p> <ul> <li>Signature: <code>public static NetworkConsole Console</code></li> </ul> <p>Description</p> <p>The <code>Console</code> property provides access to the <code>NetworkConsole</code> instance, which enables sending and receiving commands within the network terminal. This console module is used to execute commands, facilitate remote debugging, and interact with networked systems. Attempting to access this property before initializing the console module will throw an exception, ensuring that <code>InitializeModule(Module.Console)</code> is called prior to usage. Additionally, trying to set the console module more than once will result in an exception.</p> <p>Returns</p> <ul> <li><code>NetworkConsole</code>: The network console instance used for terminal commands.</li> </ul> <p>Example</p> <pre><code>try\n{\n    NetworkConsole networkConsole = NetworkManager.Console;\n    networkConsole.OnInput += OnConsoleInput;\n\n    private void OnConsoleInput(string input)\n    {\n        // Handle console input\n    }\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre>"},{"location":"api_reference/#matchmaking","title":"Matchmaking","text":"<p>Gets the <code>NetworkMatchmaking</code> instance, which provides access to the matchmaking module for managing groups and connections.</p> <ul> <li>Signature: <code>public static NetworkMatchmaking Matchmaking</code></li> </ul> <p>Description</p> <p>The <code>Matchmaking</code> property provides access to the <code>NetworkMatchmaking</code> instance, enabling functionality for creating, deleting, and joining groups in a networked environment. This module is essential for managing player groups and facilitating connections between peers for cooperative or competitive play. Attempting to access this property before initializing the matchmaking module will throw an exception, ensuring that <code>InitializeModule(Module.Matchmaking)</code> is called prior to usage. Additionally, trying to set the matchmaking module more than once will result in an exception.</p> <p>Returns</p> <ul> <li><code>NetworkMatchmaking</code>: The matchmaking instance used for group and connection management.</li> </ul> <p>Example</p> <pre><code>try\n{\n   var matchmaking = NetworkManager.Matchmaking.Server;\n   NetworkGroup group = matchmaking.AddGroup(\"Team A\");\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre>"},{"location":"api_reference/#sntp","title":"Sntp","text":"<p>Gets the <code>SimpleNtp</code> instance, which provides access to the NTP (Network Time Protocol) clock module for synchronized time and network latency metrics.</p> <ul> <li>Signature: <code>public static SimpleNtp Sntp</code></li> </ul> <p>Description</p> <p>The <code>Sntp</code> property provides access to the <code>SimpleNtp</code> instance, allowing for synchronized time between client and server. This module provides functionality for obtaining synchronized ticks or real time, as well as metrics such as round-trip time (RTT) and ping. Attempting to access this property before initializing the NTP clock module will throw an exception, ensuring that <code>InitializeModule(Module.NtpClock)</code> is called prior to usage. Additionally, attempting to set the NTP clock module more than once will result in an exception.</p> <p>Returns</p> <ul> <li><code>SimpleNtp</code>: The NTP clock instance used for synchronized time and latency measurements.</li> </ul> <p>Example</p> <pre><code>// Example of initializing and accessing the NTP clock module\nNetworkManager.InitializeModule(Module.NtpClock); // Initialize the NTP clock module\n\ntry\n{\n    var ntpClock = NetworkManager.Sntp;\n    double synchronizedTime = ntpClock.Client.Time; // Example of retrieving synchronized time\n    print(synchronizedTime);\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre>"},{"location":"api_reference/#ticksystem","title":"TickSystem","text":"<p>Gets the <code>NetworkTickSystem</code> instance, which manages tick-based events that execute at a fixed rate for consistent network timing.</p> <ul> <li>Signature: <code>public static NetworkTickSystem TickSystem</code></li> </ul> <p>Description</p> <p>The <code>TickSystem</code> property provides access to the <code>NetworkTickSystem</code> instance, responsible for executing events at a fixed rate (defined by <code>TickRate</code>) to ensure consistent timing across the network. This system is used to send and process information at a steady frequency, facilitating synchronized interactions between clients and servers. Attempting to access this property before initializing the tick system will throw an exception, ensuring that <code>InitializeModule(Module.TickSystem)</code> is called prior to usage.</p> <p>Returns</p> <ul> <li><code>NetworkTickSystem</code>: The network tick system instance, used for managing tick-based events and timing synchronization.</li> </ul>"},{"location":"api_reference/#events","title":"Events","text":""},{"location":"api_reference/#onsceneloaded","title":"OnSceneLoaded","text":"<p>An event that is triggered when a scene is loaded, providing access to the scene and the load mode.</p> <ul> <li>Signature: <code>public static event Action&lt;Scene, LoadSceneMode&gt; OnSceneLoaded</code></li> </ul> <p>Description</p> <p>The <code>OnSceneLoaded</code> event is invoked whenever a scene is loaded, passing the loaded <code>Scene</code> and the <code>LoadSceneMode</code> as parameters. This event allows for actions to be performed in response to a scene loading, such as initializing objects or updating the UI. Developers can subscribe to <code>OnSceneLoaded</code> to execute custom logic each time a new scene is loaded.</p> <p>Event Parameters</p> Parameter Type Description <code>Scene</code> <code>Scene</code> The scene that has been loaded. <code>LoadSceneMode</code> <code>LoadSceneMode</code> The mode in which the scene was loaded (<code>Single</code> or <code>Additive</code>). <p>Example</p> <pre><code>// Example of subscribing to the OnSceneLoaded event\nNetworkManager.OnSceneLoaded += (scene, mode) =&gt;\n{\n    Debug.Log($\"Scene '{scene.name}' loaded with mode: {mode}\");\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnSceneLoaded -= (scene, mode) =&gt;\n{\n    Debug.Log($\"Scene '{scene.name}' loaded with mode: {mode}\");\n};\n</code></pre>"},{"location":"api_reference/#onsceneunloaded","title":"OnSceneUnloaded","text":"<p>An event that is triggered when a scene is unloaded, providing access to the scene that was removed.</p> <ul> <li>Signature: <code>public static event Action&lt;Scene&gt; OnSceneUnloaded</code></li> </ul> <p>Description</p> <p>The <code>OnSceneUnloaded</code> event is invoked whenever a scene is unloaded, passing the <code>Scene</code> that was unloaded as a parameter. This event allows developers to execute custom logic in response to scene unloading, such as cleaning up resources, stopping specific services, or updating the user interface.</p> <p>Event Parameters</p> Parameter Type Description <code>Scene</code> <code>Scene</code> The scene that has been unloaded. <p>Example</p> <pre><code>// Example of subscribing to the OnSceneUnloaded event\nNetworkManager.OnSceneUnloaded += (scene) =&gt;\n{\n    Debug.Log($\"Scene '{scene.name}' has been unloaded.\");\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnSceneUnloaded -= (scene) =&gt;\n{\n    Debug.Log($\"Scene '{scene.name}' has been unloaded.\");\n};\n</code></pre>"},{"location":"api_reference/#onbeforesceneload","title":"OnBeforeSceneLoad","text":"<p>An event that is triggered just before a scene is loaded or unloaded, providing the scene and the operation mode (load or unload).</p> <ul> <li>Signature: <code>public static event Action&lt;Scene, SceneOperationMode&gt; OnBeforeSceneLoad</code></li> </ul> <p>Description</p> <p>The <code>OnBeforeSceneLoad</code> event is invoked right before a scene is either loaded or unloaded, passing the target <code>Scene</code> and the <code>SceneOperationMode</code> to indicate the type of operation. This event allows developers to execute preparatory logic, such as pausing certain activities or preparing resources, cleaning up resources, based on whether a scene is about to load or unload.</p> <p>Event Parameters</p> Parameter Type Description <code>Scene</code> <code>Scene</code> The scene that is about to be loaded or unloaded. <code>SceneOperationMode</code> <code>SceneOperationMode</code> Specifies whether the scene operation is a <code>Load</code> or <code>Unload</code>. <p>SceneOperationMode Enum</p> <p>The <code>SceneOperationMode</code> enum defines the operation type for a scene:</p> <ul> <li><code>Load</code>: The scene is about to be loaded.</li> <li><code>Unload</code>: The scene is about to be unloaded.</li> </ul> <p>Example</p> <pre><code>// Example of subscribing to the OnBeforeSceneLoad event\nNetworkManager.OnBeforeSceneLoad += (scene, operationMode) =&gt;\n{\n    if (operationMode == SceneOperationMode.Load)\n    {\n        Debug.Log($\"Preparing to load scene '{scene.name}'.\");\n    }\n    else if (operationMode == SceneOperationMode.Unload)\n    {\n        Debug.Log($\"Preparing to unload scene '{scene.name}'.\");\n    }\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnBeforeSceneLoad -= (scene, operationMode) =&gt;\n{\n    Debug.Log($\"Operation {operationMode} for scene '{scene.name}' is about to begin.\");\n};\n</code></pre>"},{"location":"api_reference/#onserverinitialized","title":"OnServerInitialized","text":"<p>An event that is triggered when the server has been successfully initialized.</p> <ul> <li>Signature: <code>public static event Action OnServerInitialized</code></li> </ul> <p>Description</p> <p>The <code>OnServerInitialized</code> event is invoked once the server has been fully initialized and is ready to accept connections. This event allows developers to execute custom logic or set up necessary resources immediately after the server is initialized, such as configuring game settings, starting background tasks.</p> <p>Example</p> <pre><code>// Example of subscribing to the OnServerInitialized event\nNetworkManager.OnServerInitialized += () =&gt;\n{\n    Debug.Log(\"Server has been successfully initialized and is ready for connections.\");\n    // Additional server setup code here\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnServerInitialized -= () =&gt;\n{\n    Debug.Log(\"Server initialization event listener removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onserverpeerconnected","title":"OnServerPeerConnected","text":"<p>An event that is triggered when a peer (client) connects to the server, providing access to the connected peer and the connection phase.</p> <ul> <li>Signature: <code>public static event Action&lt;NetworkPeer, Phase&gt; OnServerPeerConnected</code></li> </ul> <p>Description</p> <p>The <code>OnServerPeerConnected</code> event is invoked when a peer connects to the server, with the connection process divided into three phases (<code>Begin</code>, <code>Normal</code>, and <code>End</code>). This event provides developers with the connected <code>NetworkPeer</code> instance and the current <code>Phase</code>, allowing for custom logic to be executed at each stage of the connection.</p> <p>Event Parameters</p> Parameter Type Description <code>NetworkPeer</code> <code>NetworkPeer</code> The peer (client) that has connected to the server. <code>Phase</code> <code>Phase</code> The phase of the connection process (Begin, Normal, End). <p>Phase Enum</p> <p>The <code>Phase</code> enum defines the phases of the peer connection process:</p> <ul> <li><code>Begin</code>: Indicates the start of the connection process.</li> <li><code>Normal</code>: Represents the main connection phase, during which the primary actions are performed.</li> <li><code>End</code>: Marks the completion of the connection process, the peer is connected and authenticated, ready to use.</li> </ul> <p>Example</p> <pre><code>// Example of subscribing to the OnServerPeerConnected event\nNetworkManager.OnServerPeerConnected += (peer, phase) =&gt;\n{\n    switch (phase)\n    {\n        case Phase.Begin:\n            Debug.Log($\"Peer {peer.Id} is starting the connection process.\");\n            break;\n        case Phase.Normal:\n            Debug.Log($\"Peer {peer.Id} is now in the main connection phase.\");\n            break;\n        case Phase.End:\n            Debug.Log($\"Peer {peer.Id} has completed the connection process.\");\n            break;\n    }\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnServerPeerConnected -= (peer, phase) =&gt;\n{\n    Debug.Log($\"Listener for peer {peer.Id} connection at phase {phase} removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onserverpeerdisconnected","title":"OnServerPeerDisconnected","text":"<p>An event that is triggered when a peer (client) disconnects from the server, providing access to the disconnected peer and the disconnection phase.</p> <ul> <li>Signature: <code>public static event Action&lt;NetworkPeer, Phase&gt; OnServerPeerDisconnected</code></li> </ul> <p>Description</p> <p>The <code>OnServerPeerDisconnected</code> event is invoked when a peer disconnects from the server, with the disconnection process divided into three phases (<code>Begin</code>, <code>Normal</code>, and <code>End</code>). This event provides the <code>NetworkPeer</code> instance that is disconnecting and the current <code>Phase</code>, allowing for custom logic to be executed at each stage of the disconnection.</p> <p>Event Parameters</p> Parameter Type Description <code>NetworkPeer</code> <code>NetworkPeer</code> The peer (client) that is disconnecting from the server. <code>Phase</code> <code>Phase</code> The phase of the disconnection process (Begin, Normal, End). <p>Phase Enum</p> <p>The <code>Phase</code> enum defines the phases of the peer disconnection process:</p> <ul> <li><code>Begin</code>: Indicates the start of the disconnection process.</li> <li><code>Normal</code>: Represents the main phase of disconnection, during which the primary cleanup or disconnection actions are performed.</li> <li><code>End</code>: Marks the completion of the disconnection process, the peer has fully disconnected from the server and all resources have been cleaned up.</li> </ul> <p>Example</p> <pre><code>// Example of subscribing to the OnServerPeerDisconnected event\nNetworkManager.OnServerPeerDisconnected += (peer, phase) =&gt;\n{\n    switch (phase)\n    {\n        case Phase.Begin:\n            Debug.Log($\"Peer {peer.Id} is beginning the disconnection process.\");\n            break;\n        case Phase.Normal:\n            Debug.Log($\"Peer {peer.Id} is in the main disconnection phase.\");\n            break;\n        case Phase.End:\n            Debug.Log($\"Peer {peer.Id} has fully disconnected from the server.\");\n            break;\n    }\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnServerPeerDisconnected -= (peer, phase) =&gt;\n{\n    Debug.Log($\"Listener for peer {peer.Id} disconnection at phase {phase} removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onclientconnected","title":"OnClientConnected","text":"<p>An event that is triggered when the client successfully connects to the server.</p> <ul> <li>Signature: <code>public static event Action OnClientConnected</code></li> </ul> <p>Description</p> <p>The <code>OnClientConnected</code> event is invoked when the client establishes a successful connection with the server. This event allows developers to execute custom logic upon client connection, such as initializing UI elements, loading player data, or notifying the user of the connection status.</p> <p>Example</p> <pre><code>// Example of subscribing to the OnClientConnected event\nNetworkManager.OnClientConnected += () =&gt;\n{\n    Debug.Log(\"Client successfully connected to the server.\");\n    // Additional connection setup code here\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnClientConnected -= () =&gt;\n{\n    Debug.Log(\"Client connection listener removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onclientdisconnected","title":"OnClientDisconnected","text":"<p>An event that is triggered when the client disconnects from the server, providing a message with the disconnection reason.</p> <ul> <li>Signature: <code>public static event Action&lt;string&gt; OnClientDisconnected</code></li> </ul> <p>Description</p> <p>The <code>OnClientDisconnected</code> event is invoked when the client disconnects from the server. This event provides a string message detailing the reason for disconnection, allowing developers to display informative messages to users, handle cleanup tasks, or attempt reconnection based on the disconnection reason.</p> <p>Event Parameters</p> Parameter Type Description <code>string</code> <code>string</code> A message explaining the disconnection reason. <p>Example</p> <pre><code>// Example of subscribing to the OnClientDisconnected event\nNetworkManager.OnClientDisconnected += (reason) =&gt;\n{\n    Debug.Log($\"Client disconnected: {reason}\");\n    // Additional disconnection handling code here\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnClientDisconnected -= (reason) =&gt;\n{\n    Debug.Log(\"Client disconnection listener removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onclientidentityspawned","title":"OnClientIdentitySpawned","text":"<p>An event that is triggered when a <code>NetworkIdentity</code> is spawned on the client, providing access to the spawned identity.</p> <ul> <li>Signature: <code>public static event Action&lt;NetworkIdentity&gt; OnClientIdentitySpawned</code></li> </ul> <p>Description</p> <p>The <code>OnClientIdentitySpawned</code> event is invoked whenever a <code>NetworkIdentity</code> is successfully spawned on the client. This event provides the spawned <code>NetworkIdentity</code> instance, allowing developers to perform setup, initialize components, or trigger gameplay elements related to the spawned entity.</p> <p>Event Parameters</p> Parameter Type Description <code>NetworkIdentity</code> <code>NetworkIdentity</code> The network identity that was spawned. <p>Example</p> <pre><code>// Example of subscribing to the OnClientIdentitySpawned event\nNetworkManager.OnClientIdentitySpawned += (identity) =&gt;\n{\n    Debug.Log($\"Network identity spawned on client: {identity.name}\");\n    // Additional setup or initialization for the spawned identity\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnClientIdentitySpawned -= (identity) =&gt;\n{\n    Debug.Log(\"Client identity spawn listener removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onmessageclient","title":"OnMessage(Client)","text":"<p>Represents an event that is triggered when a custom message is received by the client, providing the message ID, data buffer, and sequence channel.</p> <ul> <li>Signature: <code>public static event Action&lt;byte, DataBuffer, int&gt; OnMessage</code></li> </ul> <p>Description</p> <p>The <code>OnMessage</code> event is invoked whenever the client receives a custom message. This event provides access to the message ID, the data buffer containing the message content, and the sequence channel. Developers can subscribe to <code>OnMessage</code> to handle incoming messages, enabling custom message processing and response handling on the client side.</p> <p>Event Parameters</p> Parameter Type Description <code>byte</code> <code>byte</code> The ID of the received message. <code>DataBuffer</code> <code>DataBuffer</code> The data buffer containing the message content. <code>int</code> <code>int</code> The sequence channel used for message ordering consistency. <p>Example</p> <pre><code>// Example of subscribing to the OnMessage event to handle incoming messages\nNetworkManager.Client.OnMessage += (msgId, dataBuffer, sequenceChannel) =&gt;\n{\n    Debug.Log($\"Received message {msgId} on sequence channel {sequenceChannel}\");\n    // Process dataBuffer as needed\n};\n\n// Example of unsubscribing from the event\nNetworkManager.Client.OnMessage -= (msgId, dataBuffer, sequenceChannel) =&gt;\n{\n    Debug.Log($\"Unsubscribed from message {msgId}\");\n};\n</code></pre>"},{"location":"api_reference/#onmessageserver","title":"OnMessage(Server)","text":"<p>An event that is triggered when a custom message is received by the server, providing access to the message ID, data buffer, originating peer, and sequence channel.</p> <ul> <li>Signature: <code>public static event Action&lt;byte, DataBuffer, NetworkPeer, int&gt; OnMessage</code></li> </ul> <p>Description</p> <p>The <code>OnMessage</code> event is invoked when the server receives a custom message, allowing developers to handle the incoming message data. This event provides the message ID, data content, the peer who sent the message, and the sequence channel used to manage message ordering. It serves as an interface for handling various types of client-server communication in a flexible manner.</p> <p>Event Parameters</p> Parameter Type Description <code>byte</code> <code>byte</code> The ID of the received message. <code>DataBuffer</code> <code>DataBuffer</code> The data buffer containing the message content. <code>NetworkPeer</code> <code>NetworkPeer</code> The peer who sent the message. <code>int</code> <code>int</code> The sequence channel used for message ordering and consistency. <p>Example</p> <pre><code>// Example of subscribing to the OnMessage event\nNetworkManager.Server.OnMessage += (msgId, dataBuffer, peer, sequenceChannel) =&gt;\n{\n    Debug.Log($\"Received message {msgId} from peer {peer.Id} on sequence channel {sequenceChannel}\");\n    // Process dataBuffer as needed\n};\n\n// Example of unsubscribing from the event\nNetworkManager.Server.OnMessage -= (msgId, dataBuffer, peer, sequenceChannel) =&gt;\n{\n    Debug.Log($\"Unsubscribed from custom message {msgId}\");\n};\n</code></pre>"},{"location":"communication/","title":"Communication","text":""},{"location":"communication/#rpc-remote-procedure-call","title":"RPC (Remote Procedure Call)","text":"<p>RPCs (Remote Procedure Calls) are a standard software industry concept that allows methods to be called on objects that are not in the same executable. They enable communication between different processes or systems over a network.</p> <p>With RPCs, a server can invoke functions on a client, and similarly, a client can invoke functions on a server. This bi-directional communication allows for flexible and dynamic interactions between clients and servers, facilitating various operations such as requesting data, executing commands, and synchronizing states across different parts of a distributed system. RPCs provide a powerful mechanism for enabling remote interactions and enhancing the functionality of networked applications.</p> <pre><code>graph LR\n  A[Ruan] ---&gt; | User Input Rpc | B{Server}\n  B ---&gt; | Move Rpc | A\n  B ---&gt; | Move Rpc | C[Junior]\n  B ---&gt; | Move Rpc | D[Mike]</code></pre> <p>Compatibility Table:</p> Base Class Compatibilidade <code>NetworkBehaviour</code> \u2705 <code>ServerBehaviour</code> \u2705 <code>ClientBehaviour</code> \u2705 <code>DualBehaviour</code> \u2705 <code>MyCustomScriptBase</code> \u2705 <p>Warning</p> <p>RPC's are also supported in base classes. If you are using a base class for network functionality, ensure that the base class name includes the <code>Base</code> prefix.  </p> Example <pre><code>public class PlayerBase : NetworkBehaviour // Note the \"Base\" prefix\n{\n}\n\npublic class Player : PlayerBase\n{\n}\n</code></pre> <p>This naming convention is required for the RPCs to function correctly in inherited classes.</p> <p>Note</p> <p>Before proceeding, refer to the Communication Structure and Service Locator Pattern pages for essential background information.</p>"},{"location":"communication/#method-signature","title":"Method Signature","text":"<p>RPC method signatures can accept up to three parameters, allowing flexibility in handling data, network information, and communication channels. The available parameters include:</p> <ul> <li>DataBuffer message: Used for receiving data sent by the client or server.</li> <li>NetworkPeer peer (Server-Only): Provides information about the client that invoked the RPC, useful for identifying the sender.</li> <li>int seqChannel: Specifies the sequence channel for the RPC, allowing control over the order and priority of messages.</li> </ul> <p>Each RPC method must be marked with the <code>[Server]</code> or <code>[Client]</code> attribute. The method name, parameters, and their order determine the specific signature of the RPC.</p> <p>Below are examples of valid RPC method signatures on the server side:</p>"},{"location":"communication/#server-side","title":"Server-Side","text":"Signature 1Signature 2Signature 3Signature 4 Signature 1 <pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void Example()\n    {\n       // This function is called on the server when a client invokes it\n    }\n}\n</code></pre> Signature 2 <pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void Example(DataBuffer message)\n    {\n       // This function is called on the server when a client invokes it\n    }\n}\n</code></pre> Signature 3 <pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void Example(DataBuffer message, NetworkPeer peer)\n    {\n       // This function is called on the server when a client invokes it\n    }\n}\n</code></pre> Signature 4 <pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void Example(DataBuffer message, NetworkPeer peer, int seqChannel)\n    {\n       // This function is called on the server when a client invokes it\n    }\n}\n</code></pre> <p>Below are examples of valid RPC method signatures on the client side:</p>"},{"location":"communication/#client-side","title":"Client-Side","text":"Signature 1Signature 2Signature 3 Signature 1 <pre><code>public class Player : NetworkBehaviour\n{\n    [Client(1)]\n    void Example()\n    {\n        // This function is called on the client when a server invokes it\n    }\n}\n</code></pre> Signature 2 <pre><code>public class Player : NetworkBehaviour\n{\n    [Client(1)]\n    void Example(DataBuffer message)\n    {\n        // This function is called on the client when a server invokes it\n    }\n}\n</code></pre> Signature 3 <pre><code>public class Player : NetworkBehaviour\n{\n    [Client(1)]\n    void Example(DataBuffer message, int seqChannel)\n    {\n        // This function is called on the client when a server invokes it\n    }\n}\n</code></pre> <p>Note</p> <p>Each RPC is assigned a unique ID within its class to ensure routing. This ID differentiates RPC methods within the same class for client-server communication.</p> <p>Warning</p> <p>RPC ID's must be between 1 and 230. An exception will be thrown if the ID is out of range. The id's are unique only within the script itself, other script instances can use the same id.</p> <p>Examples</p> Example 1 (NetworkBehaviour)Example 2 (ServerBehaviour &amp; ClientBehaviour)Example 3 (DualBehaviour) Example 1 (NetworkBehaviour) <pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void ExampleOnServer() // Signature 1\n    {\n       print(\"Wow! This works on the server!\");\n    }\n\n    [Client(1)]\n    void ExampleOnClient() // Signature 1\n    {\n       print(\"Wow! This works on the client!\");\n    }\n}\n</code></pre> Example 2 (ServerBehaviour &amp; ClientBehaviour) <pre><code>public class LoginServer : ServerBehaviour\n{\n    [Server(1)]\n    void Example() // Signature 1\n    {\n       print(\"Wow! This works on the server!\");\n    }\n}\n\npublic class LoginClient : ClientBehaviour\n{\n    [Client(1)]\n    void Example() // Signature 1\n    {\n       print(\"Wow! This works on the client!\");\n    }\n}\n</code></pre> Example 3 (DualBehaviour) <pre><code>public class Player : DualBehaviour\n{\n    [Server(1)]\n    void ExampleOnServer() // Signature 1\n    {\n       print(\"Wow! This works on the server!\");\n    }\n\n    [Client(1)]\n    void ExampleOnClient() // Signature 1\n    {\n       print(\"Wow! This works on the client!\");\n    }\n}\n</code></pre>"},{"location":"communication/#how-to-invoke-a-rpc","title":"How to Invoke a RPC","text":"<p>The <code>Local</code> and <code>Remote</code> properties are part of the public API inherited from <code>NetworkBehaviour</code>, <code>ClientBehaviour</code>, <code>ServerBehaviour</code>, and <code>DualBehaviour</code>. They are designed to facilitate communication between client and server in the network environment. Each property enforces specific usage restrictions to ensure proper client-server interactions.</p> <p>Local</p> <ul> <li>Purpose: Allows the client to invoke messages on the server.</li> <li>Restriction: This property is intended for client-side use only. Attempting to access it on the server side will throw an exception, preventing unintended server-side access.</li> <li>Usage: Useful for client-initiated communications directed at the server.</li> <li>Overloads: Invoke() has 8 overloads. For details on the available overloads, please refer to the API Reference.</li> </ul> <p>Remote</p> <ul> <li>Purpose: Allows the server to invoke messages on the client.</li> <li>Restriction: This property is intended for server-side use only. Attempting to access it on the client side will throw an exception, ensuring that only the server can utilize this property.</li> <li>Usage: Useful for server-initiated communications directed at the client.</li> <li>Overloads: Invoke() has 8 overloads. For details on the available overloads, please refer to the API Reference.</li> </ul> Example 1 (NetworkBehaviour) - Send an RPC from the client to the serverExample 2 (NetworkBehaviour) - Send an RPC from the server to the client Example 1 (NetworkBehaviour) - Send an RPC from the client to the server <pre><code>public class Player : NetworkBehaviour\n{\n    void Update()\n    {\n       // Send an RPC from the client to the server\n       if (Input.GetKeyUp(KeyCode.S) &amp;&amp; IsLocalPlayer)\n       {\n           Local.Invoke(1);\n       }\n    }\n\n    [Server(1)]\n    void Example() // Signature 1\n    {\n       print(\"Wow! This works on the server!\");\n    }\n}\n</code></pre> Example 2 (NetworkBehaviour) - Send an RPC from the server to the client <pre><code>public class Player : NetworkBehaviour\n{\n    void Update()\n    {\n       // Send an RPC from the server to the client\n       if (Input.GetKeyUp(KeyCode.A) &amp;&amp; IsServer)\n       {\n           Remote.Invoke(1);\n       }\n    }\n\n    [Client(1)]\n    void Example() // Signature 1\n    {\n       print(\"Wow! This works on the client!\");\n    }\n}\n</code></pre> <p>Invoke with <code>arguments</code>:</p> <p>Tip</p> <p>The <code>Local.Invoke()</code> and <code>Remote.Invoke()</code> methods has 8 overloads and optional arguments. However, the overloads available can vary depending on the network base class used(i.e. <code>NetworkBehaviour</code>, <code>ClientBehaviour</code>, <code>ServerBehaviour</code>, and <code>DualBehaviour</code>). For details on the available overloads, please refer to the API Reference.</p> Client-SideServer-Side Client-Side <pre><code>public class Player : NetworkBehaviour\n{\n    void Update()\n    {\n       // Send an RPC from the client to the server\n       if (Input.GetKeyUp(KeyCode.S) &amp;&amp; IsLocalPlayer)\n       {\n           using DataBuffer message = Rent();\n           message.WriteString(\"Hello World!\");\n           message.Write(123f);\n           Local.Invoke(1, message, DeliveryMode.ReliableOrdered);\n       }\n    }\n\n    [Server(1)]\n    void Example(DataBuffer message) // Signature 2\n    {\n       string str = message.ReadString();\n       float num = message.Read&lt;float&gt;();\n    }\n}\n</code></pre> Server-Side <pre><code>public class Player : NetworkBehaviour\n{\n    void Update()\n    {\n       // Send an RPC from the server to the client\n       if (Input.GetKeyUp(KeyCode.A) &amp;&amp; IsServer)\n       {\n           using DataBuffer message = Rent();\n           message.WriteString(\"Hello World!\");\n           message.Write(123f);\n           Remote.Invoke(1, message, Target.All, DeliveryMode.ReliableOrdered);\n       }\n    }\n\n    [Client(1)]\n    void Example(DataBuffer message) // Signature 2\n    {\n       string str = message.ReadString();\n       float num = message.Read&lt;float&gt;();\n    }\n}\n</code></pre> <p>Tip</p> <p><code>Invoke()</code> can send primitive values without the need a explicit <code>DataBuffer</code> object. For details on the available overloads, please refer to the API Reference.</p> Example <pre><code>   // Send an RPC from the client to the server without a explicit `DataBuffer`\n   Local.Invoke(1, transform.position, transform.rotation); // Has optional arguments\n\n   // Send an RPC from the server to the client without a explicit `DataBuffer`\n   Remote.Invoke(1, transform.position, transform.rotation, new SyncOptions()\n   {\n      DeliveryMode = DeliveryMode.Unreliable\n   });\n</code></pre> <p>Warning</p> <p>Using this overload only unmanaged types is allowed. Like <code>Vector3</code>, <code>Quaternion</code>, <code>int</code>, <code>float</code>, etc.</p>"},{"location":"communication/#network-variables","title":"Network Variables","text":"<p>At a high level, a <code>[NetworkVariable]</code> attribute is a automatic way to synchronize a property (\"variable\") between a server and client(s) without having to use custom messages or RPCs.</p> <p>Compatibility Table:</p> Base Class Compatibilidade <code>NetworkBehaviour</code> \u2705 <code>ServerBehaviour</code> \u2705 <code>ClientBehaviour</code> \u2705 <code>DualBehaviour</code> \u2705 <code>MyCustomScriptBase</code> \u2705 <p>Warning</p> <p>Network Variables are also supported in base classes. If you are using a base class for network functionality, ensure that the base class name includes the <code>Base</code> prefix.  </p> Example <pre><code>public class PlayerBase : NetworkBehaviour // Note the \"Base\" prefix\n{\n}\n\npublic class Player : PlayerBase\n{\n}\n</code></pre> <p>This naming convention is required for the Network Variables to function correctly in inherited classes.</p> <p>Note</p> <p>Before proceeding, refer to the Communication Structure and Service Locator Pattern pages for essential background information.</p>"},{"location":"communication/#how-to-use","title":"How to Use","text":"<p>Warning</p> <p>Naming Convention: The field name must be prefixed with <code>m_</code> and the first letter after the prefix must be capitalized.</p> <ul> <li>For example, <code>m_Health</code></li> <li>For example, <code>m_Mana</code></li> </ul> Example <pre><code>public partial class Player : NetworkBehaviour\n{\n    [NetworkVariable] \n    private float m_Health = 100f;\n\n    [NetworkVariable] \n    private float m_Mana = 100f;\n}\n</code></pre> <p>The class must be <code>partial</code> to use the <code>[NetworkVariable]</code> attribute.</p> <p>Note</p> <p>The <code>Omni Source Generator</code> will generate properties, hooks, options, and methods for each <code>[NetworkVariable]</code>.</p>"},{"location":"communication/#generated-properties","title":"Generated Properties","text":"<p>Generated properties in Omni are designed to automatically synchronize their values across the server and all connected clients each time the property is modified. This ensures that all instances of the property remain consistent throughout the networked environment, maintaining real-time accuracy.</p> <p>Warning</p> <p>Omni does not perform checks to determine if the new value is different from the current value. Each time the property\u2019s <code>setter</code> is invoked, the value is synchronized across the network, regardless of whether it has changed. This can lead to unnecessary network updates if the property is set to the same value repeatedly, so it is recommended to manage calls to the setter carefully to optimize performance.</p> Automatically Synchronized <pre><code>public partial class Player : NetworkBehaviour\n{\n    [NetworkVariable] \n    private float m_Health = 100f;\n    [NetworkVariable] \n    private float m_Mana = 100f;\n}\n\nvoid Update()\n{\n   if(IsServer &amp;&amp; Input.GetKeyUp(KeyCode.N))\n   {\n      // Automatically synchronized\n      Health -= 10f;\n      Mana += 10f;\n   }\n}\n</code></pre> <p>Tip</p> <p>You can modify the underlying field directly instead of the property if you don\u2019t want automatic synchronization. To manually synchronize the modified field, simply call:</p> <ul> <li><code>SyncHealth(DefaultNetworkVariableOptions)</code></li> <li><code>SyncMana(DefaultNetworkVariableOptions)</code></li> </ul> <p>for immediate network updates.</p> Manually Synchronized <pre><code>public partial class Player : NetworkBehaviour\n{\n    [NetworkVariable] \n    private float m_Health = 100f;\n\n    void Update()\n    {\n        if(IsServer &amp;&amp; Input.GetKeyUp(KeyCode.N))\n        {\n            // Manually synchronized\n            m_Health -= 10f;\n            SyncHealth();\n        }\n    }\n}\n</code></pre> <p>Warning</p> <p>If you modify a field immediately after instantiating a networked object or within <code>Awake()</code> or <code>Start()</code>, the variable will synchronize correctly. This is because, during object initialization, the server automatically sends updates for network variables to clients. However, if you modify the property instead of the field at these early stages, synchronization may fail. Property changes trigger an update message, but if the object has not yet been instantiated on the client side, the update will not be applied.</p> <p>Bug</p> <p>Occasionally, generated code may not be recognized by the IDE\u2019s IntelliSense (e.g., in Visual Studio). If this occurs, a simple restart of the IDE should resolve the issue.</p>"},{"location":"communication/#default-behaviour","title":"Default Behaviour","text":"<p>Tip</p> <p>Use <code>DefaultNetworkVariableSettings</code> to adjust how network variables are transmitted across the network. This allows for configuring default behaviors for all network variables. For more specific control, you can use individual settings like <code>HealthOptions</code> and <code>ManaOptions</code> to customize the transmission behavior of specific variables.</p> Example <pre><code>public partial class Player : NetworkBehaviour\n{\n    [NetworkVariable] \n    private float m_Health = 100f;\n\n    [NetworkVariable] \n    private float m_Mana = 100f;\n\n    protected override OnAwake()\n    {\n        // Change the default settings for all network variables\n        DefaultNetworkVariableOptions = new()\n        {\n            DeliveryMode = DeliveryMode.ReliableOrdered\n        };\n\n        // Change specific settings for specific network variables\n        HealthOptions = new()\n        {\n            DeliveryMode = DeliveryMode.ReliableOrdered\n            Target = Target.All\n        };\n\n        ManaOptions = new()\n        {\n            DeliveryMode = DeliveryMode.ReliableOrdered\n            Target = Target.All\n        };\n    }\n}\n</code></pre>"},{"location":"http_lite/","title":"Overview","text":"<p>Http Lite is a simple simulation of <code>Express.js</code> and is one of the most useful features of the API. It can be easily used to request a route and receive a response from the server. Routes can also send responses to multiple clients beyond the one that originally requested the route.</p>"},{"location":"http_lite/#basic-usage","title":"Basic Usage","text":"<ol> <li>Import the <code>Http Lite</code> module with <code>using static Omni.Core.HttpLite;</code></li> <li>Register the routes on the <code>Awake</code> method or on the <code>Start</code> method, eg:</li> </ol> <p>Note</p> <p>Http Lite supports both asynchronous and synchronous operations, with all functions having their asynchronous versions.</p> <pre><code>Http.GetAsync(\"/login\", (res) =&gt;\n{\n    res.WriteString(\"Hello World!\");\n    res.Send();\n});\n</code></pre> <p>Tip</p> <p>Send() has overloads and optional arguments, allowing you to specify the recipient, delivery method, group, channel, cache, and more.</p> <ul> <li>Send with Target and Delivery Method (optional)</li> </ul> <pre><code>Http.GetAsync(\"/login\", (res) =&gt;\n{\n    res.WriteString(\"Hello World!\");\n    res.Send(HttpTarget.GroupMembers, DeliveryMode.ReliableOrdered); // Send the response to all group members &amp; deliver in reliable order\n});\n</code></pre> <p>Note</p> <p>When specifying that a route should send the response to clients other than the one that requested the route, you must ensure that these clients also register the route to receive the response.</p> <p>The default <code>HttpTarget</code> is <code>Self</code>, meaning that only the client that requested the route will receive the response.</p> <ul> <li>Request the route from the client.</li> </ul> <pre><code>async void RequestLogin()\n{\n    using var res = await Fetch.GetAsync(\"/login\");\n    string result = res.ReadString();\n    print(result);\n}\n</code></pre> <p>Here is the complete <code>example</code> if you want to test it. Attach this code to a script that is in the scene and press <code>Enter</code>.</p> <pre><code>void Start()\n{\n    Http.GetAsync(\"/login\", (res) =&gt;\n    {\n        res.WriteString(\"Hello World!\");\n        res.Send();\n    });\n}\n\nasync void RequestLogin()\n{\n    using var res = await Fetch.GetAsync(\"/login\");\n    string result = res.ReadString();\n    print(result);\n}\n\nprivate void Update()\n{\n    if (Input.GetKeyDown(KeyCode.Return))\n    {\n        RequestLogin();\n    }\n}\n</code></pre> <p>After pressing <code>Enter</code>, the console should display -&gt; \"Hello World\".</p> <p>Remember, this example uses the asynchronous method, which I always recommend using.</p> <p>Here is an example of the asynchronous version of <code>Post</code>.</p> <ul> <li>Register a <code>Post</code> route.</li> </ul> <pre><code>Http.PostAsync(\"/login\", (req, res) =&gt;\n{\n    // Read the username sent in the request\n    string username = req.ReadString()\n    // Send a response\n    res.WriteString(\"Your are logged in as \" + username);\n    res.Send();\n});\n</code></pre> <ul> <li>Request the route from the client.</li> </ul> <pre><code>using var res = await Fetch.PostAsync(\"/login\", req =&gt;\n{\n    req.WriteString(\"John Doe\");\n})\n\nstring result = res.ReadString();\nprint(result);\n</code></pre> <p>Here is the complete <code>example</code> if you want to test it. Attach this code to a script that is in the scene and press <code>Enter</code>.</p> <pre><code>void Start()\n{\n    Http.PostAsync(\"/login\", (req, res) =&gt;\n    {\n        // Read the username sent in the request\n        string username = req.ReadString();\n        // Send a response\n        res.WriteString(\"Your are logged in as \" + username);\n        res.Send();\n    });\n}\n\nasync void RequestLogin()\n{\n    using var res = await Fetch.PostAsync(\"/login\", req =&gt;\n    {\n        req.WriteString(\"John Doe\");\n    });\n\n    string result = res.ReadString();\n    print(result);\n}\n\nprivate void Update()\n{\n    if (Input.GetKeyDown(KeyCode.Return))\n    {\n        RequestLogin();\n    }\n}\n</code></pre> <p>Tip</p> <p>On the server side, it is possible to obtain the client that is requesting the route by adding a third argument when registering the route.</p> <pre><code>Http.PostAsync(\"/login\", (req, res, peer) =&gt; {});\nHttp.GetAsync(\"/login\", (res, peer) =&gt; {});\n</code></pre> <p><code>Peer</code> is a <code>NetworkPeer</code> object that represents the client that is requesting the route.</p>"},{"location":"serialization/","title":"Serialization","text":""},{"location":"serialization/#overview","title":"Overview","text":"<p>Omni is capable of serializing various types of data, including primitives, complex classes, structures, dictionaries, and more. Omni offers two types of serialization: JSON-based and binary-based serialization.</p> <p>All network operations are performed using the <code>DataBuffer</code> object, which represents a buffer of data to be sent over the network.</p>"},{"location":"serialization/#basic-usage-of-databuffer","title":"Basic Usage of DataBuffer","text":"<ul> <li>Basic serialization</li> </ul> <pre><code>void Start()\n{\n    DataBuffer buffer = new DataBuffer(1024); // Size of the buffer in bytes,     this argument is optional, the default size is 32768\n    buffer.Write(10);\n    buffer.WriteString(\"Hello World!\");\n}\n</code></pre> <ul> <li>Using JSON serialization with <code>DataBuffer</code></li> </ul> <pre><code>public class Player\n{\n    public string name;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.WriteAsJson(new Player());\n}\n</code></pre> <ul> <li>Using binary serialization with <code>DataBuffer</code></li> </ul> <pre><code>[MemoryPackable]\npublic partial class Player\n{\n    public string health;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.WriteAsBinary(new Player());\n}\n</code></pre> <ul> <li>Complex serialization with <code>DataBuffer</code></li> </ul> <pre><code>[MemoryPackable]\npublic partial class Player\n{\n    public string health;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.Write(3287382);\n    buffer.WriteAsBinary(new Player());\n    buffer.WriteAsJson(new Player());\n    buffer.WriteString(\"Hello World!\");\n}\n</code></pre> <p>Warning</p> <p>When sending a <code>DataBuffer</code>, you will always receive a <code>DataBuffer</code> in response; it is not possible to send and receive data in any other way without using a <code>DataBuffer</code>, as all operations utilize it internally. You must also ensure that the reading and writing occur in the same order.</p> <p>If you write an <code>integer</code> followed by a <code>string</code>, you must read an <code>integer</code> followed by a <code>string</code>. Never attempt to read the data in an order different from the one in which it was written, as this will result in incorrect data retrieval and potential errors.</p> <p>Omni uses the Newtonsoft.Json library for JSON serialization.</p> <p>For binary serialization, Omni employs the MemoryPack library.</p> <p>For more details, please refer to the documentation:</p> <ul> <li>JSON Serialization: Newtonsoft.Json Documentation</li> <li>Binary Serialization: MemoryPack GitHub Repository</li> </ul>"},{"location":"spawning/","title":"Spawning","text":""},{"location":"spawning/#overview","title":"Overview","text":"<p>Omni supports spawning objects on both the server and client, providing several methods for network object instantiation. In this guide, we\u2019ll walk you through the available options, from the simplest to the most advanced approaches, enabling you to choose the best method based on your project\u2019s requirements.</p> <p>Each method allows for a different level of control over networked objects, from basic automatic spawning to more complex, customizable instantiation processes.</p>"},{"location":"spawning/#simple-instantiation","title":"Simple Instantiation","text":"<p>The Network Object Spawner component provides a quick and efficient way to instantiate networked objects, making it ideal for prototyping stages. This component simplifies the process by automatically handling the instantiation of both prefabs and scene objects over the network. </p> <p>With Network Object Spawner, you can set up networked objects with minimal configuration, allowing you to focus on testing gameplay and mechanics rather than complex network setups.</p> <ul> <li>Add the <code>Network Object Spawner</code> component to any game object in your scene.</li> </ul> Field Description Local Player A <code>NetworkIdentity</code> reference for the object that will be controlled by the local player. This object will receive input and commands directly from the local player. Objects to Spawn A list of <code>NetworkIdentity</code> references for objects to be managed by the server. These objects will be instantiated over the network and controlled by the server. <p>Using this setup, the <code>Network Object Spawner</code> manages instantiation and synchronization, simplifying networked spawning for both player-controlled and server-managed objects.</p> <p>Tip</p> <p>You can add either a prefab or a scene object to the Local Player or Objects to Spawn list, depending on your project\u2019s requirements.</p>"},{"location":"spawning/#manual-instantiation","title":"Manual Instantiation","text":"<p>If you want to instantiate a networked object manually in a straightforward way, here are some examples to guide you. Manual instantiation provides you with more control over when and where the networked object appears in the scene, ideal for scenarios where specific logic or conditions dictate object creation. </p> <p>Follow these examples to quickly and easily get started with manual instantiation of networked objects in your project.</p> <p>First example:</p> <pre><code>   // Cache to store all spawn-related messages.\n   private DataCache m_SpawnCache = new DataCache(CachePresets.ServerNew);\n\n   protected override void OnServerPeerConnected(NetworkPeer peer, Phase phase)\n   {\n       // Ensure actions occur only after the client is fully connected and authenticated.\n       if (phase == Phase.End) // Phase.End: Indicates the client is authenticated and ready for network interactions\n       {\n           // Retrieve the first registered prefab from the NetworkManager\u2019s prefab list. \n           // Note: you can also use:\n           // var prefab = NetworkManager.GetPrefab(\"PrefabName\");\n           NetworkIdentity prefab = NetworkManager.GetPrefab(0);\n\n           // Spawn the prefab for the connected peer and pass the spawn cache\n           prefab.Spawn(peer, dataCache: m_SpawnCache);\n\n           // Send the cached spawn data to the connected peer, allowing late-joining players to \n           // receive all relevant spawn information and ensuring they have a consistent game state.\n           m_SpawnCache.SendToPeer(peer);\n       }\n   }\n</code></pre> <p>Tip</p> <ul> <li><code>NetworkManager.GetPrefab</code> offers two overloads: one for retrieving a prefab by its name and another for accessing a prefab by its index in the registered prefab list.</li> <li><code>prefab.Spawn</code> offers two overloads and optional arguments to control the spawn process.</li> </ul> <p>Check de API reference for more details.</p>"}]}