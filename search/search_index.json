{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Omni Networking is a comprehensive networking solution that offers features for high-performance multiplayer game development in Unity. Omni provides functionalities for database management, simulated HTTP, RPC, gRPC, port forwarding, network variables, binary and JSON serialization, among others.</p> <p>Omni supports only versions 2021.2 and above, as it utilizes the latest APIs available in .NET Standard 2.1 and beyond to achieve the highest possible performance.</p>"},{"location":"#installation","title":"Installation","text":"<p>Warning</p> <p>Before getting started, it's important to be aware that Omni includes some dependencies by default:</p> <ul> <li>Newtonsoft Json</li> <li>Memory Pack</li> <li>UniTask</li> <li>DOTween</li> <li>Database modules, among others.</li> </ul> <p>Make sure to remove these dependencies from your project if they already exist. For this reason, I recommend always starting with a new project to avoid any conflicts.</p> <ol> <li>Download the latest Omni package from the Releases.</li> <li>Import the package into your project.</li> </ol>"},{"location":"#setup","title":"Setup","text":"<p>Note</p> <p>After importing the package and waiting for the recompilation, some macros are automatically defined:</p> <ul> <li><code>OMNI_RELEASE</code></li> <li><code>OMNI_DEBUG</code></li> <li><code>OMNI_SERVER</code> is defined when the target platform is set to <code>DEDICATED SERVER</code>.</li> </ul> <p>You can use these macros to switch between release and debug builds.</p> <pre><code>#if OMNI_RELEASE\nprint(\"You're in release mode\");\n#endif\n\n#if OMNI_DEBUG\nprint(\"You're in debug mode\");\n#endif\n\n#if OMNI_SERVER\nprint(\"You're in server mode\");\n#endif\n</code></pre> <ol> <li>Go to the Unity Navigation Bar and select <code>Omni Networking</code>.</li> <li>Click the <code>Setup</code> menu item.</li> </ol> <p>A GameObject named <code>Network Manager</code> will be created in the scene. This object is responsible for the connection and contains all the network settings.</p> <p>Warning</p> <p>The <code>Network Manager</code> object must be in the scene for Omni to function properly and not should be destroyed or renamed.</p> <p>Note</p> <p>The <code>Network Manager</code> object, There are two child objects that can be optionally used to run client and server scripts. Remember, it is optional to place scripts on these objects. When scripts are placed on these two objects, they will be automatically separated during the build process. In release mode, server scripts will not be executed in the client build, and vice versa. Note that this does not strip the code; it merely prevents it from being executed by removing the objects from the scene at build time.</p> <p>To strip the code, it is recommended to use the macros <code>OMNI_RELEASE</code>, <code>OMNI_DEBUG</code>, <code>OMNI_SERVER</code>.</p> <ol> <li>Select the <code>Network Manager</code> object in the scene to view the network settings.</li> </ol> Option Description <code>Public IPv4</code> The public IPv4 address of the client <code>Public IPv6</code> The public IPv6 address of the client"},{"location":"#modules","title":"Modules","text":"Modules Description <code>Console Module</code> Allows sending and receiving commands in the console when the build is for a server. <code>Match Module</code> Allows matchmaking, creating, joining, and deleting groups, among other features. <code>Tick Module</code> Allows the use of a tick-based system for sending messages and other tick-based operations. <code>Sntp Module</code> Provides a high-precision synchronized clock between all clients and the server."},{"location":"#connection-settings","title":"Connection Settings","text":"Option Description <code>Server Port</code> The port number on which the server listens for incoming connections. <code>Client Port</code> The port number on which the client listens for incoming connections. Option Description <code>Host Address</code> The IP address or hostname of the server to which the client will connect. <code>Port</code> The port number on which the server is listening and which will be used for the connection."},{"location":"#miscellaneous","title":"Miscellaneous","text":"Option Description <code>Tick Rate</code> The rate at which the game loop processes updates, measured in ticks per second. <code>Max Fps On Client</code> The maximum frame rate that the client will attempt to render, measured in frames per second. <code>Auto Start Server</code> Whether the server should automatically start when the application launches. <code>Auto Start Client</code> Whether the client should automatically start when the application launches. <code>Use UTF-8 Encoding</code> Whether to use UTF-8 encoding for text data in the application. <code>Use Binary Serialization</code> Coming soon. <code>Use Unaligned Memory</code> Whether to allow unaligned memory access, which may affect performance and compatibility. <code>Run In Background</code> Whether the application should continue running while in the background, even when not in focus."},{"location":"#registered-prefabs","title":"Registered Prefabs","text":"<p>This list is used to automatically instantiate network objects. When a network object is instantiated by name or indexer, the object will be looked up in this list and instantiated automatically. Remember, manual instantiation is also available, and using this list is not required.</p>"},{"location":"#transporter-settings","title":"Transporter Settings","text":"<p>The Transporter Settings section configures network transport parameters such as disconnection time, network event processing per frame, lag simulation, channels, IPv6 support, and ping interval, etc. The available options depend on the selected transporter.</p> <p>Currently, we have two available transporters, with plans to add more in the future: Lite and KCP Transporter.</p>"},{"location":"http_lite/","title":"Overview","text":"<p>Http Lite is a simple simulation of <code>Express.js</code> and is one of the most useful features of the API. It can be easily used to request a route and receive a response from the server. Routes can also send responses to multiple clients beyond the one that originally requested the route.</p>"},{"location":"http_lite/#basic-usage","title":"Basic Usage","text":"<ol> <li>Import the <code>Http Lite</code> module with <code>using static Omni.Core.HttpLite;</code></li> <li>Register the routes on the <code>Awake</code> method or on the <code>Start</code> method, eg:</li> </ol> <p>Note</p> <p>Http Lite supports both asynchronous and synchronous operations, with all functions having their asynchronous versions.</p> <pre><code>Http.GetAsync(\"/login\", (res) =&gt;\n{\n    res.WriteString(\"Hello World!\");\n    res.Send();\n});\n</code></pre> <p>Tip</p> <p>Send() has overloads and optional arguments, allowing you to specify the recipient, delivery method, group, channel, cache, and more.</p> <ul> <li>Send with Target and Delivery Method (optional)</li> </ul> <pre><code>Http.GetAsync(\"/login\", (res) =&gt;\n{\n    res.WriteString(\"Hello World!\");\n    res.Send(HttpTarget.GroupMembers, DeliveryMode.ReliableOrdered); // Send the response to all group members &amp; deliver in reliable order\n});\n</code></pre> <p>Note</p> <p>When specifying that a route should send the response to clients other than the one that requested the route, you must ensure that these clients also register the route to receive the response.</p> <p>The default <code>HttpTarget</code> is <code>Self</code>, meaning that only the client that requested the route will receive the response.</p> <ul> <li>Request the route from the client.</li> </ul> <pre><code>async void RequestLogin()\n{\n    using var res = await Fetch.GetAsync(\"/login\");\n    string result = res.ReadString();\n    print(result);\n}\n</code></pre> <p>Here is the complete <code>example</code> if you want to test it. Attach this code to a script that is in the scene and press <code>Enter</code>.</p> <pre><code>void Start()\n{\n    Http.GetAsync(\"/login\", (res) =&gt;\n    {\n        res.WriteString(\"Hello World!\");\n        res.Send();\n    });\n}\n\nasync void RequestLogin()\n{\n    using var res = await Fetch.GetAsync(\"/login\");\n    string result = res.ReadString();\n    print(result);\n}\n\nprivate void Update()\n{\n    if (Input.GetKeyDown(KeyCode.Return))\n    {\n        RequestLogin();\n    }\n}\n</code></pre> <p>After pressing <code>Enter</code>, the console should display -&gt; \"Hello World\".</p> <p>Remember, this example uses the asynchronous method, which I always recommend using.</p> <p>Here is an example of the asynchronous version of <code>Post</code>.</p> <ul> <li>Register a <code>Post</code> route.</li> </ul> <pre><code>Http.PostAsync(\"/login\", (req, res) =&gt;\n{\n    // Read the username sent in the request\n    string username = req.ReadString()\n    // Send a response\n    res.WriteString(\"Your are logged in as \" + username);\n    res.Send();\n});\n</code></pre> <ul> <li>Request the route from the client.</li> </ul> <pre><code>using var res = await Fetch.PostAsync(\"/login\", req =&gt;\n{\n    req.WriteString(\"John Doe\");\n})\n\nstring result = res.ReadString();\nprint(result);\n</code></pre> <p>Here is the complete <code>example</code> if you want to test it. Attach this code to a script that is in the scene and press <code>Enter</code>.</p> <pre><code>void Start()\n{\n    Http.PostAsync(\"/login\", (req, res) =&gt;\n    {\n        // Read the username sent in the request\n        string username = req.ReadString();\n        // Send a response\n        res.WriteString(\"Your are logged in as \" + username);\n        res.Send();\n    });\n}\n\nasync void RequestLogin()\n{\n    using var res = await Fetch.PostAsync(\"/login\", req =&gt;\n    {\n        req.WriteString(\"John Doe\");\n    });\n\n    string result = res.ReadString();\n    print(result);\n}\n\nprivate void Update()\n{\n    if (Input.GetKeyDown(KeyCode.Return))\n    {\n        RequestLogin();\n    }\n}\n</code></pre> <p>Tip</p> <p>On the server side, it is possible to obtain the client that is requesting the route by adding a third argument when registering the route.</p> <pre><code>Http.PostAsync(\"/login\", (req, res, peer) =&gt; {});\nHttp.GetAsync(\"/login\", (res, peer) =&gt; {});\n</code></pre> <p><code>Peer</code> is a <code>NetworkPeer</code> object that represents the client that is requesting the route.</p>"},{"location":"rpc/","title":"Overview","text":"<p>RPCs (Remote Procedure Calls) are a standard software industry concept that allows methods to be called on objects that are not in the same executable. They enable communication between different processes or systems over a network.</p> <p>With RPCs, a server can invoke functions on a client, and similarly, a client can invoke functions on a server. This bi-directional communication allows for flexible and dynamic interactions between clients and servers, facilitating various operations such as requesting data, executing commands, and synchronizing states across different parts of a distributed system. RPCs provide a powerful mechanism for enabling remote interactions and enhancing the functionality of networked applications.</p>"},{"location":"rpc/#basic-usage","title":"Basic Usage","text":"<p>In Omni, RPCs work with any scripts that inherit from NetworkBehaviour, <code>ClientBehaviour</code>, <code>DualBehaviour</code>, or <code>ServerBehaviour</code>. The differences between them are as follows:</p> <ul> <li><code>NetworkBehaviour</code>: Used for objects instantiated with an identity.</li> <li><code>DualBehaviour</code>: Allows you to program both client and server logic in the same script. It cannot be instantiated and does not have an identity.</li> <li><code>ClientBehaviour</code> and <code>ServerBehaviour</code>: Used to program behaviors in separate scripts for client and server respectively. These cannot be instantiated and do not have an identity.</li> </ul>"},{"location":"rpc/#usage","title":"Usage...","text":"<p>An example of RPCs in the same script, handling both client and server logic:</p> <p>Note</p> <p>The method signatures can have up to three arguments for server methods and two arguments for client methods, with all arguments being optional.</p> <p>The full signature for server methods is:</p> <pre><code>[Server(id)]\nvoid name_of_method(DataBuffer buffer, NetworkPeer peer, int seqChannel) {}\n</code></pre> <p>The full signature for client methods is:</p> <pre><code>[Client(id)]\nvoid name_of_method(DataBuffer buffer, int seqChannel) {}\n</code></pre> <p>All arguments are optional, but they must be in the correct order and be of the correct type.</p> <p><code>without arguments:</code></p> <pre><code>[Server(id)]\nvoid name_of_method() {}\n</code></pre> <p>The signature for client methods is:</p> <pre><code>[Client(id)]\nvoid name_of_method() {}\n</code></pre> <p><code>one argument:</code></p> <pre><code>[Server(id)]\nvoid name_of_method(DataBuffer buffer) {}\n</code></pre> <p>The signature for client methods is:</p> <pre><code>[Client(id)]\nvoid name_of_method(DataBuffer buffer) {}\n</code></pre> <p><code>two arguments:</code></p> <pre><code>[Server(id)]\nvoid name_of_method(DataBuffer buffer, NetworkPeer peer) {}\n</code></pre> <p>The signature for client methods is:</p> <pre><code>[Client(id)]\nvoid name_of_method(DataBuffer buffer, int seqChannel) {}\n</code></pre> <p>Only the server method can have a <code>NetworkPeer</code> parameter.</p> <ul> <li>Let's send an RPC containing a simple message:</li> </ul> <pre><code>[Server(1)]\nvoid OnMsg_Server(DataBuffer buffer)\n{\n    print(\"received message: \" + buffer.ReadString() + \" from client\");\n}\n\n[Client(1)]\nvoid OnMsg_Client(DataBuffer buffer)\n{\n    print(\"received message: \" + buffer.ReadString() + \" from server\");\n}\n</code></pre> <p>In this example, we are invoking the RPC on the client that is connected to the server.</p> <pre><code>protected override void OnServerPeerConnected(NetworkPeer peer, Phase phase)\n{\n    if (phase == Phase.End)\n    {\n        DataBuffer buffer = new DataBuffer();\n        buffer.WriteString(\"Hello! (:)\");\n        Remote.Invoke(1, peer, buffer);\n    }\n}\n</code></pre> <p>Note</p> <ul> <li> <p>The <code>Remote.Invoke</code> method: This method is used by the server to     call RPCs on a connected client. It allows the server to request that the     client execute a specific method or operation remotely.</p> </li> <li> <p>The <code>Local.Invoke</code> method: This method is used by the client to     call RPCs on the server. It allows the client to request that the server     execute a specific method or operation remotely.</p> </li> </ul> <p>The <code>id</code> parameter is the ID of the RPC, used to identify the RPC on the server and client on the same object.</p> <p>Note</p> <p>The method <code>Invoke</code> has overloads and optional arguments, allowing you to specify the recipient, delivery method, group, channel, cache, and more.</p> <p>Here is the complete <code>example</code> if you want to test it. Attach this code to a script that is in the scene.</p> <pre><code>[Server(1)]\nvoid OnMsg_Server(DataBuffer buffer)\n{\n    print(\"received message: \" + buffer.ReadString() + \" from client\");\n}\n\n[Client(1)]\nvoid OnMsg_Client(DataBuffer buffer)\n{\n    print(\"received message: \" + buffer.ReadString() + \" from server\");\n}\n\nprotected override void OnServerPeerConnected(NetworkPeer peer, Phasphase)\n{\n    if (phase == Phase.End)\n    {\n        DataBuffer buffer = new DataBuffer();\n        buffer.WriteString(\"Hello! (:)\");\n        Remote.Invoke(1, peer, buffer);\n    }\n}\n</code></pre> <ul> <li>Send an RPC from the client to the server:</li> </ul> <pre><code>private void Update()\n{\n    if (Input.GetKeyDown(KeyCode.G))\n    {\n        DataBuffer buffer = new DataBuffer();\n        buffer.WriteString(\"Hello! (:)\");\n        Local.Invoke(1, buffer);\n    }\n}\n</code></pre> <p>Note</p> <p>Remember that we are inheriting from <code>DualBehaviour</code>, which implements the logic for both in the same script. <code>Local.Invoke</code> is not available when inheriting from <code>ServerBehaviour</code>, as it only contains server logic, and any client RPC signatures will be ignored. The same applies to <code>ClientBehaviour</code>, where <code>Remote.Invoke</code> is not available because it only handles client logic, and any server RPC signatures will be ignored;</p> <p><code>NetworkBehaviour</code> should be used for objects that are instantiated on the network and have an identity.</p> <ul> <li>Let's create a messaging chat to clearly demonstrate the use of RPCs. This time, we will keep the logic in separate scripts.</li> </ul>"},{"location":"serialization/","title":"Overview","text":"<p>Omni is capable of serializing various types of data, including primitives, complex classes, structures, dictionaries, and more. Omni offers two types of serialization: JSON-based and binary-based serialization.</p> <p>All network operations are performed using the <code>DataBuffer</code> object, which represents a buffer of data to be sent over the network.</p>"},{"location":"serialization/#basic-usage-of-databuffer","title":"Basic Usage of DataBuffer","text":"<ul> <li>Basic serialization</li> </ul> <pre><code>void Start()\n{\n    DataBuffer buffer = new DataBuffer(1024); // Size of the buffer in bytes,     this argument is optional, the default size is 32768\n    buffer.Write(10);\n    buffer.WriteString(\"Hello World!\");\n}\n</code></pre> <ul> <li>Using JSON serialization with <code>DataBuffer</code></li> </ul> <pre><code>public class Player\n{\n    public string name;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.WriteAsJson(new Player());\n}\n</code></pre> <ul> <li>Using binary serialization with <code>DataBuffer</code></li> </ul> <pre><code>[MemoryPackable]\npublic partial class Player\n{\n    public string health;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.WriteAsBinary(new Player());\n}\n</code></pre> <ul> <li>Complex serialization with <code>DataBuffer</code></li> </ul> <pre><code>[MemoryPackable]\npublic partial class Player\n{\n    public string health;\n    public int score;\n}\n\nvoid Start()\n{\n    DataBuffer buffer = new DataBuffer(1024);\n    buffer.Write(3287382);\n    buffer.WriteAsBinary(new Player());\n    buffer.WriteAsJson(new Player());\n    buffer.WriteString(\"Hello World!\");\n}\n</code></pre> <p>Warning</p> <p>When sending a <code>DataBuffer</code>, you will always receive a <code>DataBuffer</code> in response; it is not possible to send and receive data in any other way without using a <code>DataBuffer</code>, as all operations utilize it internally. You must also ensure that the reading and writing occur in the same order.</p> <p>If you write an <code>integer</code> followed by a <code>string</code>, you must read an <code>integer</code> followed by a <code>string</code>. Never attempt to read the data in an order different from the one in which it was written, as this will result in incorrect data retrieval and potential errors.</p> <p>Omni uses the Newtonsoft.Json library for JSON serialization.</p> <p>For binary serialization, Omni employs the MemoryPack library.</p> <p>For more details, please refer to the documentation:</p> <ul> <li>JSON Serialization: Newtonsoft.Json Documentation</li> <li>Binary Serialization: MemoryPack GitHub Repository</li> </ul>"}]}